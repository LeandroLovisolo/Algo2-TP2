\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{enumitem}
\usepackage{algorithmic}
\usepackage{scrextend}


\setenumerate{noitemsep}


\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros nuestros                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%InterfazFuncion(nombre, argumentos, valor retorno)
\newcommandx{\InterfazAlgoritmo}[3]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}%
}

%Algoritmo(nombre, argumentos, valor retorno) { cuerpo }%
\newenvironmentx{Algoritmo}[3]{%
  \InterfazAlgoritmo{#1}{#2}{#3}
  \begin{addmargin}[2em]{0em}
    \begin{algorithmic}
}
{
    \end{algorithmic}
  \end{addmargin}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TAD DatosCategoría                                                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{TAD \tadNombre{DatosCategoría}}

\begin{tad}{\tadNombre{DatosCategoría}}
\tadGeneros{datoscat}
\tadExporta{datoscat, generadores, observadores básicos, idDC, esRaíz?, padreDC, hijosDC}
\tadUsa{\tadNombre{Bool, Nat, Categoria, Conjunto(Categoria), ArbolCategorias}}

\tadIgualdadObservacional{dc}{dc'}{datoscat}{nombreDC($dc$) $\igobs$ nombreDC($dc'$) $\land$ \\ acatDC($dc$) $\igobs$ acatDC($dc'$)}

\tadAlinearFunciones{categoriasADatosCat}{conj(categoria)/cs, acat/ac}
\tadGeneradores

\tadOperacion{crearDatosCat}{categoria/c,acat/ac}{datoscat}{c $\in$ categorias(ac)}

\tadObservadores

\tadOperacion{nombreDC}{datoscat}{categoria}{}
\tadOperacion{acatDC}{datoscat}{acat}{}

\tadOtrasOperaciones

\tadOperacion{idDC}{datoscat}{nat}{}
\tadOperacion{esRaíz?}{datoscat}{bool}{}
\tadOperacion{padreDC}{datoscat/dc}{datoscat}{$\neg$ esRaíz?($dc$)}
\tadOperacion{hijosDC}{datoscat}{conj(datoscat)}{}
\tadOperacion{categoríasADatosCat}{conj(categoria)/cs, acat/ac}{conj(datoscat)}{cs $\subseteq$ categorias(ac)}

\tadAlinearAxiomas{nombreDC(crearDatosCat($c$, $ac$))}
\tadAxiomas[\paratodo{categoria}{c}, \paratodo{conj(categoria)}{cs}, \paratodo{acat}{ac}]

\tadAxioma{nombreDC(crearDatosCat($c$, $ac$))}{$c$}
\tadAxioma{acatDC(crearDatosCat($c$, $ac$))}{$ac$}
\tadAxioma{idDC(crearDatosCat($c$, $ac$))}{id($ac$, $c$)}
\tadAxioma{esRaíz?(crearDatosCat($c$, $ac$))}{$c$ $\igobs$ raíz($ac$)}
\tadAxioma{padreDC(crearDatosCat($c$, $ac$))}{crearDatosCat(padre($ac$, $c$), $ac$)}
\tadAxioma{hijosDC(crearDatosCat($c$, $ac$))}{categoriasADatosCat(hijos($ac$, $c$), $ac$)}
\tadAxioma{categoríasADatosCat($cs$, $ac$)}{\TADIF $\emptyset$?($cs$)
                                            THEN $\emptyset$
                                            ELSE Ag(crearDatosCat(dameUno($cs$), $ac$), sinUno($cs$))
                                            FI}

\end{tad}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Árbol de Categorías                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo ÁrbolCategorías}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{DatosCategoría}, \tadNombre{ÁrbolCategorías}, \tadNombre{Iterador Unidireccional(Categoría)}.

  \textbf{géneros}: \TipoVariable{acat}, \TipoVariable{datoscat}, \TipoVariable{itercat}.

  \Titulo{Operaciones básicas de árbol de categorías}
  
  \InterfazFuncion{CrearÁrbol}{\In{raiz}{categoria}}{acat}
  [$¬$vacía?($raiz$)]
  {$res$ $\igobs$ nuevo($raiz$)}
  [$\Theta(|raiz|)$]
  [crea un árbol nuevo cuya categoría raíz es $raiz$.]

  \InterfazFuncion{NombreCategoríaRaíz}{\In{ac}{acat}}{categoria}
  {$res$ $\igobs$ raíz($ac$)}
  [$\Theta(1)$]
  [devuelve el nombre de la categoría raíz de $ac$.]

  \InterfazFuncion{AgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{acat}}{}
  [$ac$ $\igobs$ $ac_{0}$ $\land$ está?($padre$, $ac$) $\land$ $¬$vacía?($hija$) $\land$ $¬$está?($hija$, $ac$)]
  {$ac$ $\igobs$ agregar($ac_{0}$, $padre$, $hija$)}
  [$\Theta(|padre| + |hija|)$]
  [agrega la categoría $hija$ como hija de la categoría $padre$.]

  \InterfazFuncion{CrearIterCat}{\In{padre}{categoria}, \In{ac}{acat}}{itercat}
  [está?($padre$, $ac$)]
  {alias(esPermutacion?(SecuSuby($res$), hijos($ac$, $padre$))) $\land$ vacia?(Anteriores($res$))}
  [$\Theta(|padre|)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría $padre$.]

  DUDA: ¿Puedo tratar a $res$ acá directamente como un itConj($\alpha$) en la expresión SecuSuby($res$)?
  
  DUDA: ¿Hay que extender el TAD ÁrbolCategorías como en el apunte de módulos básicos
        para poder especificar la operación esPermutacion??
     
  \InterfazFuncion{IdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{acat}}{nat}
  [está?($c$, $ac$)]
  {$res$ $\igobs$ id($ac$, $c$)}
  [$\Theta(|c|)$]
  [devuelve el $id$ de la categoría $c$.]
  
  \Titulo{Operaciones de datos de categoría}
          
  \InterfazFuncion{ObtenerId}{\In{dc}{datoscat}}{nat}
  {$res$ $\igobs$ idDC($dc$)}
  [$\Theta(1)$]
  [devuelve el $id$ de la categoría asociada a $dc$.]  

  \InterfazFuncion{ObtenerNombre}{\In{dc}{datoscat}}{nat}
  {$res$ $\igobs$ nombreDC($dc$)}
  [$\Theta(1)$]
  [devuelve el nombre de la categoría asociada a $dc$.]  

  \InterfazFuncion{ObtenerPadre}{\In{dc}{datoscat}}{puntero(datoscat)}
  [$\neg$ esRaíz?($dc$)]
  {$res$ $\igobs$ padreDC($dc$)}
  [$\Theta(1)$]
  [devuelve un puntero a los datos de la categoría padre asociada a $dc$.]  

  DUDA: ¿Está bien la postcondición? $res$ es de tipo puntero(datoscat), mientras que padreDC devuelve datoscat.

  \InterfazFuncion{ObtenerHijos}{\In{dc}{datoscat}}{conj(puntero(datoscat))}
  {$res$ $\igobs$ hijosDC($dc$)}
  [$\Theta(1)$]
  [devuelve un conjunto de punteros a los datos de las categorías hijas directas asociadas a $dc$.]  

  DUDA: ¿Está bien la postcondición? $res$ es de tipo conj(puntero(datoscat)), mientras que hijosDC devuelve conj(datoscat).

  \Titulo{Operaciones de iterador de categorías}
  
  \InterfazFuncion{HayMás?}{\In{it}{itercat}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{Actual}{\In{it}{itercat}}{puntero(datoscat)}
  [HayMás?($it$)]
  {$res$ $\igobs$ Actual($it$)}
  [$\Theta(1)$]
  [devuelve el elemento actual del iterador.]

  \InterfazFuncion{Avanzar}{\Inout{it}{itercat}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$res$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]  

\end{Interfaz}

~

\begin{Representacion}

  \Titulo{Representación de árbol de categorías}

  \begin{Estructura}{acat}[estr\_acat]
    \begin{Tupla}[estr\_acat]
      \tupItem{raíz}{puntero(datoscat)}%
      \tupItem{categorías}{dicctrie(datoscat)}%
    \end{Tupla}
  \end{Estructura}

  Invariante de representación:

  \begin{enumerate}
    \item raíz no puede ser nulo.
    \item raíz tiene que estar en el diccionario de categorías.
    \item raíz tiene que tener id 1.
    \item para todas las categorías en el diccionario:
    \begin{enumerate}
      \item la categoría no puede ser nula.
      \item el nombre de la categoría deber ser igual a su clave en el diccionario.
      \item el id de la categoría debe estar en rango.      
      \item dos categorías no pueden tener el mismo id.      
      \item los hijos de la categoría tienen que estar en el diccionario de categorías.
      \item el padre es nulo si y sólo si la categoría es la raíz.
      \item si el padre no es nulo, tiene que estar en el diccionario de categorías.
      \item si el padre no es nulo, la categoría está entre los hijos del padre.
      \item si el padre no es nulo, el id de la categoría debe ser superior al del padre.
    \end{enumerate}
  \end{enumerate}

  \Rep[estr\_acat][e]{ \\
      (1) \hspace*{0mm} $¬$($e$.raíz $\igobs$ NULL) $\yluego$ \\
      (2) \hspace*{0mm} def?($e$.raíz\DRef nombre, $e$.categorías) $\yluego$
                        obtener($e$.raíz\DRef nombre, $e$.categorías) $\igobs$ $e$.raíz $\land$ \\      
      (3) \hspace*{0mm} $e$.raíz\DRef id $\igobs$ 1 $\land$ \\
      (4) \hspace*{0mm} ($\forall c$: categoria)(def?($c$, $e$.categorías) $\impluego$ ( \\
      (4a) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías) $\igobs$ NULL) $\yluego$ \\
      (4b) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef nombre $\igobs$ $c$ $\yluego$ \\
      (4c) \hspace*{5mm} 1 $\leq$ obtener($c$, $e$.categorías)\DRef id $\land$
                        obtener($c$, $e$.categorías)\DRef id $\leq$ \#(claves($e$.categorías)) $\land$ \\
      (4d) \hspace*{5mm} ($\forall c'$: categoría)(obtener($c$, $e$.categorías)\DRef id $\igobs$
                                                  obtener($c'$, $e$.categorías)\DRef id $\ssi$
                                                  $c$ $\igobs$ $c'$) $\land$ \\
      (4e) \hspace*{5mm} ($\forall h$: puntero(datoscat))($h$ $\in$ obtener($c$, $e$.categorías)\DRef hijos $\impluego$ \\
          \hspace*{20mm} def?($h$\DRef nombre, $e$.categorías)) $\yluego$ \\
      (4f) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL $\ssi$ $c$ $\igobs$ $e$.raíz\DRef nombre $\yluego$ \\      
      (4g) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} def?(obtener($c$, $e$.categorías)\DRef padre\DRef nombre, $e$.categorías) $\yluego$ \\
      (4h) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías) $\in$ obtener($c$, $e$.categorías)\DRef padre\DRef hijos) $\land$ \\ 
      (4i) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías)\DRef padre\DRef id < \ obtener($c$, $e$.categorías)\DRef id))
  }

  \mbox{}

  DUDA: ¿Está bien acceder a los campos de datoscat como si fuera una tupla?
        Notar que se usa el género datoscat en vez de su estructura de representación estr\_datoscat.

  ~  
  
  DUDA: Para acortar el Rep, ¿puedo declarar variables dentro del mismo? Ejemplo:\\
        \hspace*{20mm} $x$ $\igobs$ obtener($c$, $e$.categorías) $\land$ $¬$($x$\DRef padre $\igobs$ NULL) $\impluego$ \\
        \hspace*{30mm} (def?($x$\DRef padre\DRef nombre, $e$.categorías) $\yluego$ $x$ $\in$ $x$\DRef padre\DRef hijos)

  ~

  \Abs[estr\_acat]{acat}[e]{ac}
    {categorias($ac$) $\igobs$ claves($e$.categorías) $\yluego$ \\
    raíz($ac$) $\igobs$ $e$.raíz\DRef nombre $\land$ \\
    ($\forall c$: categoria)($c$ $\in$ claves($e$.categorías) $\impluego$ ( \\
    \hspace*{5mm} padre($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef padre\DRef nombre $\land$ \\
    \hspace*{5mm} id($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef id))
  }

  ~

  \Titulo{Representación de datos de categoría}  
  
  \begin{Estructura}{datoscat}[estr\_datoscat]
    \begin{Tupla}[estr\_datoscat]
      \tupItem{id}{nat}
      \tupItem{nombre}{categoria}
      \tupItem{padre}{puntero(datoscat)}
      \tupItem{hijos}{conj(puntero(datoscat))}
    \end{Tupla}
  \end{Estructura} 

  DUDA: ¿Hace falta crear un TAD nuevo para poder expresar el Rep y Abs del género datoscat?
        De ser así, ¿tengo que agregar dicho TAD en la lista 'se explica con'?

  ~

  \Titulo{Representación de iterador de categorías}  
  
  \begin{Estructura}{itercat}[itConj(puntero(datoscat))]
  \end{Estructura} 

  DUDA: ¿Está bien la estructura de representación elegida?

  DUDA: ¿Qué usamos para expresar el Rep y el Abs en este caso? Dado que se trata de un
        itConj($\alpha$), suena razonable pensar en usar el Rep y Abs de este iterador
        definidos en el módulo Conjunto Lineal($\alpha$).

  ~  

\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearÁrbol}{\In{raiz}{categoria}}{estr\_acat}
  	\STATE var $raiz\_estr$: \TipoVariable{estr\_datoscat}
	\STATE var $categorias$: \TipoVariable{dicctrie(estr\_datoscat)}
  	\STATE
    \STATE $raiz\_estr$ $\leftarrow$ $\langle$\TipoVariable{id}: 1, \TipoVariable{nombre}: $raiz$,
                                      \TipoVariable{padre}: NULL, \TipoVariable{hijos}: \NombreFuncion{Vacío}()$\rangle$
    \STATE $categorias$ $\leftarrow$ \NombreFuncion{CrearDiccionario}()
  	\STATE    
    \STATE \NombreFuncion{Definir}($raiz$, \&($raiz\_estr$), $categorias$)
   	\STATE
  	\STATE $res$ $\leftarrow$ $\langle$\TipoVariable{raiz}: \&($raiz\_estr$), \TipoVariable{categorias}: $categorias\rangle$
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iNombreCategoríaRaíz}{\In{ac}{estr\_acat}}{categoria}
	\STATE $res \leftarrow ac.raiz\DRef nombre$  
  \end{Algoritmo}  

  ~
  
  \begin{Algoritmo}{iAgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{estr\_acat}}{}
  	\STATE var $estr\_hija$: \TipoVariable{estr\_datoscat}
  	\STATE $estr\_hija$ $\leftarrow$ $\langle$\TipoVariable{id}: \NombreFuncion{\#Claves}($ac.categorias$) + 1,
  	                                          \TipoVariable{nombre}: $hija$, \\
  	                                          \hspace*{22mm}
  	                                          \TipoVariable{padre}: \NombreFuncion{Obtener}($padre$, $ac.categorias$),
  	                                          \TipoVariable{hijos}: \NombreFuncion{Vacío}() $\rangle$
    \STATE \NombreFuncion{Definir}($hija$, $estr\_hija$, $ac$)
  \end{Algoritmo}
  
\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LinkLinkIt                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Módulo LinkLinkIt}

\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{LinkLinkIt}, \tadNombre{Iterador Unidireccional(Link)}.

  \textbf{géneros}: \TipoVariable{sistema}, \TipoVariable{iterlinks}.

  \Titulo{Operaciones básicas del sistema}
  
  \InterfazFuncion{CrearSistema}{\In{ac}{acat}}{sistema}
  {$res$ $\igobs$ iniciar($ac$)}
  [$\Theta$(\#(categorías($ac$))]
  [crea un sistema cuyo árbol de categorías es $ac$.]

  \InterfazFuncion{AgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $¬$($l$ $\in$ links($s$)) $\land$ está?($c$, categorías($s$)]
  {$s$ $\igobs$ nuevoLink($s_{0}$, $l$, $c$)}
  [$\Theta$(|$l$| + |$c$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [agrega al sistema el link $l$ con categoría $c$.]

  \InterfazFuncion{AccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $l$ $\in$ links($s$) $\land$ $f$ $\geq$ fechaActual($s$)]
  {$s$ $\igobs$ acceso($s_{0}$, $l$, $f$)}
  [$\Theta$(|$l$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [registra un acceso al link $l$ en la fecha $f$.]

  \InterfazFuncion{\#Links}{\In{c}{categoría}, \In{s}{sistema}}{nat}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ cantLinks($s$, $c$)}
  [$\Theta$(|$c$|)]
  [devuelve la cantidad de links bajo la categoría $c$ y todas sus subcategorías.]

  \InterfazFuncion{CrearIterLinks}{\In{c}{categoría}, \In{s}{sistema}}{iterlinks}
  [está?($c$, categorías($s$))]
  {alias(SecuSuby($res$) $\igobs$ linksOrdenadosPorAccesos($ac$, $padre$)) $\land$ vacia?(Anteriores($res$))}
  [$\Theta$(|$c$| + $n$·log($n$)), donde $n$ representa long(linksOrdenadosPorAccesos($s$, $c$)).]
  [devuelve un iterador unidireccional de los links de la categoría $c$ y todas sus subcategorías ordenados de mayor a menor cantidad de accesos recientes.]
  
  \Titulo{Operaciones de iterador de links}
  
  \InterfazFuncion{HayMás?}{\In{it}{iterlinks}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{LinkActual}{\In{it}{iterlinks}}{link}
  [HayMás?($it$)]
  {$res$ $\igobs$ Actual($it$)}
  [$\Theta(1)$]
  [devuelve el link actual del iterador.]

  \InterfazFuncion{CategoríaLinkActual}{\In{it}{iterlinks}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ categoríaLink(???, Actual($it$))}
  [$\Theta(1)$]
  [devuelve la categoría del link actual del iterador.]
  
  DUDA: En la postcondición no dispongo de un sistema para la llamada a categoríaLink, pues la
        interfaz de la función no recibe un sistema como parámetro ya que toda la información
        que necesita el algoritmo está contenida en el iterador. ¿Cómo hago para especificar
        la postcondición si no tengo un sistema?
        

  \InterfazFuncion{AccesosRecientesLinkActual}{\In{it}{iterlinks}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ accesosRecientes(???, ???, Actual($it$))}
  [$\Theta(1)$]
  [devuelve la cantidad de accesos del link actual del iterador durante los días de la intersección
   de los tres días ``recientes'' del link $l$ y de los tres días ``recientes'' del link que tuvo
   último acceso entre los links de la categoría $c$ con la que se creó este iterador, y los links
   de todas sus subcategorías.]

  DUDA: Misma duda que en la función anterior: ¿cómo hago para especificar la postcondición si
        no dispongo ni de la categoría ni del sistema para la llamada a accesosRecientes?

  \InterfazFuncion{Avanzar}{\Inout{it}{iterlinks}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$res$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]  
  
\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación del sistema}
  
  \begin{Estructura}{sistema}[estr\_sistema]
    \begin{Tupla}[estr\_sistema]
      \tupItem{categorías}{acat}
      \tupItem{links}{dicctrie(estr\_link)}
      \tupItem{linksPorCatId}{arreglo\_dimensionable de estr\_linkscat}
      \tupItem{fechaActual}{fecha}
    \end{Tupla}
    \begin{Tupla}[estr\_link]
      \tupItem{l}{link}
      \tupItem{cid}{nat}
      \tupItem{últimoAcceso}{fecha}
      \tupItem{as}{arreglo\_estático[3] de fecha}            
    \end{Tupla} \\
    \begin{Tupla}[estr\_linkscat]
      \tupItem{c}{puntero(datoscat)}
      \tupItem{ls}{lista(puntero(estr\_link))}
      \tupItem{últimoAcceso}{fecha}      
      \tupItem{ordenado?}{bool}            
    \end{Tupla}    
  \end{Estructura}
  
  \Titulo{Representación de iterador de links}  
  
  \begin{Estructura}{iterlinks}[estr\_iter]
    \begin{Tupla}[estr\_iter]
      \tupItem{s}{estr\_sistema}
      \tupItem{c}{categoria}
      \tupItem{it}{itLista(puntero(estr\_link))}
    \end{Tupla}
  \end{Estructura}
  
\end{Representacion}

\begin{Algoritmos}

  Pendiente.

\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diccionario Trie                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo Diccionario Trie($\alpha$)}

\begin{Interfaz}
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Diccionario(String, $\alpha$)}, \tadNombre{Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{dicctrie$(\alpha)$}, \TipoVariable{iterdicctrie($\alpha$)}.

  \Titulo{Operaciones básicas de diccionario trie}
  
  \InterfazFuncion{CrearDiccionario}{}{dicctrie$(\alpha)$}
  {$res$ $\igobs$ vacío()}
  [$\Theta(1)$]
  [crea un nuevo diccionario vacío.]

  \InterfazFuncion{Definido?}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{bool}
  {$res$ $\igobs$ def?($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve \textbf{true} si y sólo si $c$ está definido en el diccionario.]

  \InterfazFuncion{Definir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{dicctrie$(\alpha)$}}{}
  [$d$ $\igobs$ $d_{0}$]
  {$d$ $\igobs$ definir($d_{0}$, $c$, $s$)}
  [$\Theta(|c| + copy(s))$]
  [define la clave $c$ con el significado $s$ en el diccionario.]
  
  \InterfazFuncion{Obtener}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{$\alpha$}
  [def?($c$, $d$)]
  {$res$ $\igobs$ obtener($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve el significado de la clave $c$ en $d$.]  
   
  \InterfazFuncion{\#Claves}{\In{d}{dicctrie$(\alpha)$}}{nat}
  {$res$ $\igobs$ \#(claves($d$))}
  [$\Theta(1)$]
  [devuelve la cantidad de claves del diccionario.]    
  
  \Titulo{Operaciones del iterador}
  
  Pendiente.

\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación de diccionario trie}
  
  \begin{Estructura}{dicctrie$(\alpha)$}[estr\_dicctrie]
  	\begin{Tupla}[estr\_dicctrie]
  		\tupItem{cantClaves}{nat}
  		\tupItem{nodos}{nodo}
  	\end{Tupla}
    	\begin{Tupla}[nodo]
      \tupItem{nodos}{arreglo\_estático[256] de puntero(nodo)}
      \tupItem{significado}{puntero$(\alpha)$}
    \end{Tupla}
  \end{Estructura}
  
    \Abs[estr\_dicctrie]{dicc(string, $\alpha$)}[e]{d}
    {($\forall c$: string) Definido?($c$, $e$) $\igobs$ def?($c$, $d$) $\land$ \\
    Definido?($c$,$e$) $\impluego$ (Obtener($c$, $e$) $\igobs$ obtener($c$, $e$))}  
  
  \Titulo{Representación del iterador}  
  
  ~  
  
  Pendiente.
\end{Representacion}

~

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearDiccionario}{}{estr\_dicctrie}
  	\STATE var $i$: \TipoVariable{nat}
  	\STATE $res$.cantClaves $\leftarrow$ 0
  	\STATE for $i$=0 to |$res$.nodos| do:
  	\STATE \hspace*{10mm} $res$.nodos[i] $\leftarrow$ false
	\STATE endFor
	\STATE $res$.nodos.significado $\leftarrow$ NULL
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iObtener}{\In{c}{string}, \In{e}{estr\_dicctrie}}{$\alpha$}
  	\STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$  \NombreFuncion{\&}($e.nodos$)
  	\STATE var $i$: \TipoVariable{nat}
  	\STATE for $i$=0 to |$c$| do:
  	\STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
	\STATE endFor
    \STATE $res$ $\leftarrow$ (*$nodoActual$).(*$significado$)
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iDefinir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{e}{estr\_dicctrie}}{}
  	\STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$  \NombreFuncion{\&}($e.nodos$)
  	\STATE var $i$: \TipoVariable{nat}
  	\STATE for $i$=0 to |$c$| do:
  	\STATE \hspace*{10mm} if (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] = NULL then:
  	\STATE \hspace*{20mm} var $nuevoNodo$: \TipoVariable{estr\_dicctrie}
	\STATE \hspace*{20mm} for $j$=0 to |$nuevoNodo.nodos$| do:
	\STATE \hspace*{30mm} $nuevoNodo$.nodos[$i$] $\leftarrow$ NULL
	\STATE \hspace*{20mm} endFor
	\STATE \hspace*{20mm} $nuevoNodo$.significiado $\leftarrow$ NULL
	
	\STATE \hspace*{20mm}(*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] $\leftarrow$ \NombreFuncion{\&}($nuevoNodo$)
	\STATE \hspace*{10mm} endIf
	\STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
	\STATE endFor
	\STATE (*$nodoActual$).significado $\leftarrow$ \NombreFuncion{\&}(\NombreFuncion{Copia}($s$))
	\STATE $e$.cantClaves++
  \end{Algoritmo}

  ~  
   
    \begin{Algoritmo}{iDefinido?}{\In{c}{string}, \In{e}{estr\_dicctrie}}{bool}
    \STATE var $i$: \TipoVariable{nat}
  	\STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$  \NombreFuncion{\&}($e.nodos$)
  	\STATE while $i$ < |$c$| $\land$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] != NULL do:
  	\STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
  	\STATE \hspace*{10mm} $i$++
	\STATE endWhile
	\STATE $res$ $\leftarrow$ ($i$ = |$c$|-1 $\land$ (*$nodoActual$).siginficado != NULL)
  \end{Algoritmo}

  ~  
     
 \begin{Algoritmo}{i\#Claves}{}{nat}
 	$res$ $\leftarrow$ $e$.cantClaves
 \end{Algoritmo} 
\end{Algoritmos}

\end{document}