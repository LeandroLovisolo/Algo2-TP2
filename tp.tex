\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{enumitem}
\usepackage{algorithmic}
\usepackage{scrextend}
\usepackage{framed}

\setenumerate{noitemsep}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[2]{\emph{#1}: \TipoVariable{#2}}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs $#4$: #2 $\mid$ \phantom{}}%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs $#4$: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%

\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros nuestros                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%margen: margen de uso general
\newcommandx{\margen}{\hspace*{5mm}}

%InterfazFuncion(nombre, argumentos, valor retorno)
\newcommandx{\InterfazAlgoritmo}[3]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}%
}

\algsetup{indent=2em, linenodelimiter=.}

%Algoritmo(nombre, argumentos, valor retorno, complejidad, justificacion) { cuerpo }
\newenvironmentx{Algoritmo}[5]{%
  \def \complejidad {#4}
  \def \justificacion {#5}

  \begin{oframed}
    \InterfazAlgoritmo{#1}{#2}{#3}  
    \begin{addmargin}[2em]{0em}
      \begin{algorithmic}[1]
}
{
      \end{algorithmic}
    \end{addmargin}
    \vspace*{0.5em}%
    \hspace*{\parindent}\textbf{Complejidad:} \complejidad%
    \ifthenelse{\equal{\justificacion}{}}{}{
      \vspace*{0.5em}%
      \begin{addmargin}[\parindent + 1em]{0em}
        \justificacion
      \end{addmargin}    
    }
  \end{oframed}
}

%CrearTupla(variable donde se almacenará)
\newlength{\margenTupla}
\newcommandx{\CrearTupla}[1]{%
  \settowidth{\margenTupla}{#1 $\leftarrow$ $\langle$}%  
  #1 $\leftarrow$ $\langle$%  
}

%MargenTupla
\newcommandx{\MargenTupla}{\hspace*{\margenTupla}}

%CampoTupla(campo, valor)
\newcommandx{\CampoTupla}[2]{\TipoVariable{#1}: #2}

%FinTupla
\newcommandx{\FinTupla}{$\rangle$}

%CompTheta(complejidad)
\newcommandx{\CompTheta}[1]{\hfill $\Theta$(#1)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Árbol de Categorías                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo ÁrbolCategorías}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{ÁrbolCategorías}, \tadNombre{Iterador Unidireccional(Categoría)}.

  \textbf{géneros}: \TipoVariable{acat}, \TipoVariable{itcats}.

  \Titulo{Operaciones básicas de árbol de categorías}
  
  \InterfazFuncion{CrearÁrbol}{\In{raiz}{categoria}}{acat}
  [$¬$vacía?($raiz$)]
  {$res$ $\igobs$ nuevo($raiz$)}
  [$\Theta(|raiz|)$]
  [crea un árbol nuevo cuya categoría raíz es $raiz$.]

  \InterfazFuncion{NombreCategoríaRaíz}{\In{ac}{acat}}{categoria}
  {$res$ $\igobs$ raíz($ac$)}
  [$\Theta(1)$]
  [devuelve el nombre de la categoría raíz de $ac$.]
  [$res$ no es modificable.]

  \InterfazFuncion{AgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{acat}}{}
  [$ac$ $\igobs$ $ac_{0}$ $\land$ está?($padre$, $ac$) $\land$ $¬$vacía?($hija$) $\land$ $¬$está?($hija$, $ac$)]
  {$ac$ $\igobs$ agregar($ac_{0}$, $padre$, $hija$)}
  [$\Theta(|padre| + |hija|)$]
  [agrega la categoría $hija$ como hija de la categoría $padre$.]
   
  \InterfazFuncion{IdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{acat}}{nat}
  [está?($c$, $ac$)]
  {$res$ $\igobs$ id($ac$, $c$)}
  [$\Theta(|c|)$]
  [devuelve el $id$ de la categoría $c$.]

  \InterfazFuncion{\#Categorías}{\In{ac}{acat}}{nat}
  {$res$ $\igobs$ \#(categorias($ac$))}
  [$\Theta(1)$]
  [devuelve la cantidad de categorías en $ac$.]
  
  \Titulo{Operaciones del iterador de categorías}

  \InterfazFuncion{CrearIt}{\In{padre}{categoria}, \In{ac}{acat}}{itcats}
  [está?($padre$, $ac$)]
  {$res$ $\igobs$ CrearItUni(tuplasHijos($padre$, $ac$)) $\land$ alias(iteraLosHijos($res$, $padre$, $ac$))}
  [$\Theta(|padre|)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría $padre$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría $padre$.]

  \InterfazFuncion{CrearItRaíz}{\In{ac}{acat}}{itcats}
  {$res$ $\igobs$ CrearItUni(tuplasHijos(raíz($ac$), $ac$)) $\land$ alias(iteraLosHijos($res$, raíz($ac$), $ac$))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría raíz de $ac$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría raíz.]

  \InterfazFuncion{CrearItDadoOtroIt}{\In{it}{itcats}, \In{ac}{acat}}{itcats}
  [HayMás?($it$)]
  {$res$ $\igobs$ CrearItUni(tuplasHijos($\Pi_1$(Actual($it$)), $ac$)) $\land$ alias(iteraLosHijos($res$, $\Pi_1$(Actual($it$)), $ac$))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría actual del iterador $it$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría actual del iterador $it$.]

  \InterfazFuncion{HayMás?}{\In{it}{itcats}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{CategoríaActual}{\In{it}{itcats}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_1$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve el elemento actual del iterador.]
  [$res$ no es modificable.]

  \InterfazFuncion{IdCategoríaActual}{\In{it}{itcats}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_2$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve el id del elemento actual del iterador.]

  \InterfazFuncion{Avanzar}{\Inout{it}{itcats}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it_{0}$)]
  {$it$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  {
    \offinterlineskip
    \begin{tad}{\tadNombre{Árbol Extendido}}
      \tadExtiende{\tadNombre{ÁrbolCategorías}}

      \tadTitulo{otras operaciones (no exportadas)}{}

      \tadAlinearFunciones{categoríasATuplas}{conj(categoría)/cc,acat/ac}
      \tadOperacion{tuplasHijos}{categoría/c,acat/ac}{secu(tupla(categoría{, }nat))}{está?($c$, $ac$)}
      \tadAlinearFunciones{categoríasATuplas}{conj(categoría)/cc,acat/ac}
      \tadOperacion{categoríasATuplas}{conj(categoría)/cc,acat/ac}{secu(tupla(categoría{, }nat))}{$cc$ $\subseteq$ categorías($ac$)}
      \tadAlinearFunciones{categoríasATuplas}{secu(tupla(categoría{, }nat)), secu(tupla(categoría{, }nat))}
      \tadOperacion{iteraLosHijos}{itUni(tupla(categoría{, }nat)),categoría/c,acat/ac}{bool}{está?($c$, $ac$)}
      \tadOperacion{terminanIgual}{secu(tupla(categoría{, }nat)), secu(tupla(categoría{, }nat))}{bool}{}  

      \tadAxiomas[\paratodo{categoría}{c}, \paratodo{acat}{ac}, \paratodo{conj(categoría)}{cc}, \paratodo{secu(categoría)}{sc},\\
                  \paratodo{secu(tupla(categoría{, }nat))}{st, st'}, \paratodo{itUni(tupla(categoría{, }nat))}{it}]  
  
      \tadAlinearAxiomas{aliasingHijos($it$, $c$, $ac$)}
      \tadAxioma{tuplasHijos($c$, $ac$)}{catsATuplas(hijos($ac$, $c$), $ac$)}      
      \tadAxioma{catsATuplas($cc$, $ac$)}{\TADIF $\emptyset$?($cc$)
                                          THEN \secuencia{}
                                          ELSE \secuencia{$\langle$dameUno($cc$){, }id($ac${, }dameUno($cc$))$\rangle$}
                                                         [categoríasATuplas(sinUno($cc$), $ac$)]
                                          FI}
      \tadAxioma{iteraLosHijos($it$, $c$, $ac$)}{terminanIgual(Siguientes($it$), tuplasHijos($c$, $ac$))}
      \tadAxioma{terminanIgual($st$, $st'$)}{\TADIF vacía?($st$) $\lor$ vacía($st'$)
                                             THEN \textbf{true}
                                             ELSE ult($st$) $\igobs$ ult($st'$) $\land$ terminanIgual(com($st$), com($st'$))
                                             FI}       
    \end{tad}
  }
  
\end{Interfaz}

~

\begin{Representacion}

  \Titulo{Representación del árbol de categorías}

  \begin{Estructura}{acat}[estr\_acat]
    \begin{Tupla}[estr\_acat]
      \tupItem{raíz}{estr\_cat},\\
      \tupItem{categorías}{dicctrie(estr\_cat)}%
    \end{Tupla}

    \begin{Tupla}[estr\_cat]
      \tupItem{id}{nat},\\
      \tupItem{nombre}{categoria},\\
      \tupItem{hijos}{conj(puntero(estr\_cat))}%
    \end{Tupla}    
  \end{Estructura}
 
  ~

  \textbf{Invariante de representación:}

  \begin{enumerate}
    \item La raíz tiene que estar en el diccionario de categorías.
    \item La raíz tiene que tener id 1.
    \item Para todas las categorías en el diccionario:
    \begin{enumerate}
      \item El nombre de la categoría deber ser igual a su clave en el diccionario.
      \item El id de la categoría debe estar en rango.      
      \item Dos categorías no pueden tener el mismo id.
      \item Para todos los hijos de la categoría:
      \begin{enumerate}
        \item El hijo no puede ser nulo.
        \item El hijo tiene que estar en el diccionario de categorías.
        \item El hijo no puede estar en el conjunto de hijos de otra categoría.
        \item El hijo debe tener un id superior al de la categoría padre.
      \end{enumerate}        
    \end{enumerate}
  \end{enumerate}

  \Rep[estr\_acat][e]{ \\
    def?($e$.raíz.nombre, $e$.categorías) $\land$ \hfill 1. \\
    $e$.raíz.id $\igobs$ 1 $\land$ \hfill 2. \\
    ($\forall c$: categoria)(def?($c$, $e$.categorías) $\impluego$ ( \hfill 3. \\
      \margen $cat$.nombre $\igobs$ $c$ $\land$ \hfill 3. a) \\
      \margen 1 $\leq$ $cat$.id $\land$ $cat$.id $\leq$ \#(claves($e$.categorías)) $\land$ \hfill 3. b) \\
      \margen ($\forall c'$: categoria)(def?($c'$, $e$.categorías) $\impluego$ ($cat$.id $\igobs$ $cat'$.id $\ssi$
                                                                                $c$ $\igobs$ $c'$)) $\land$ \hfill 3. c) \\
      \margen ($\forall h$: puntero(estr\_cat))($h$ $\in$ $cat$.hijos $\impluego$ ( \hfill 3. d) \\
        \margen\margen $¬$($h$ $\igobs$ NULL) $\yluego$ \hfill 3. d) 1) \\
        \margen\margen def?($h$\DRef nombre, $e$.categorías) $\yluego$ $h$ $\igobs$ \&(obtener($h$\DRef nombre, $e$.categorías)) $ \land$ \hfill 3. d) 2) \\
        \margen\margen ($\forall c'$: categoria)(def?($c'$, $e$.categorías) $\impluego$ ($h$ $\in$ $cat'$.hijos $\ssi$
                                                                                         $c$ $\igobs$ $c'$)) $\land$ \hfill 3. d) 3) \\
        \margen\margen $h$\DRef id $>$ $cat$.id \hfill 3. d) 4) \\
      \margen )) \\
    )), donde $cat$ es obtener($c$, $e$.categorías) y $cat'$ es obtener($c'$, $e$.categorías).
  }

  \mbox{}

  ~
 
  \textbf{Función de abstracción:}
  
  \begin{enumerate}
    \item El conjunto de categorías del árbol debe ser igual al conjunto de claves del diccionario de la estructura.
    \item La raíz del árbol debe ser igual a la raíz de la estructura.
    \item Para todas las categorías en el árbol:
    \begin{enumerate}
      \item El id en el árbol y la estructura deben coincidir.
      \item Los hijos de la categoría en la estructura deben tener como padre a la categoría en el árbol.
    \end{enumerate}
  \end{enumerate}

  \Abs[estr\_acat]{acat}[e]{ac}{%
    categorias($ac$) $\igobs$ claves($e$.categorías) $\yluego$ \hfill 1. \\
    raíz($ac$) $\igobs$ $e$.raíz.nombre $\land$ \hfill 2. \\
    ($\forall c$: categoria)($c$ $\in$ categorías($ac$) $\impluego$ ( \hfill 3. \\
      \margen id($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías).id $\land$ \hfill 3. a) \\
      \margen ($\forall h$: puntero(estr\_cat))($h$ $\in$ obtener($c$, $e$.categorías).hijos) $\impluego$ \hfill 3. b) \\
        \margen\margen padre($ac$, $h$\DRef nombre) $\igobs$ $c$ \\
      \margen ) \\
    ))
  }

  ~

  \Titulo{Representación del iterador}  
  
  \begin{Estructura}{itcats}[itConj(puntero(estr\_cat))]
  \end{Estructura}
  
  \textbf{Invariante de representación:}

  \begin{enumerate}
    \item La secuencia de elementos siguientes del iterador no puede contener punteros nulos.
  \end{enumerate}

  \Rep[itConj(puntero(estr\_cat))][it]{
    $¬$(está?(NULL, Siguientes($it$))) \hfill 1.
  }

  \mbox{}

  \textbf{Función de abstracción:}
  
  \begin{enumerate}
    \item Los elementos siguientes del iterador deben ser las tuplas (categoría, nat) que se correspondan
          con los elementos siguientes de la instancia de itConj(puntero(estr\_cat)).
  \end{enumerate}

  \Abs[itConj(puntero(estr\_cat))]{itUni(tupla(categoría, nat))}[itconj]{it}{%
    Siguientes($it$) $\igobs$ SecuDeTuplas(Siguientes($itconj$)) \hfill 1.
  }

  ~
  
  \tadOperacion{SecuDeTuplas}{secu(puntero(estr\_cat))/sp}{secu(tupla(categoria, nat))}{$¬$(está?(NULL, $sp$)}
  \tadAxioma{SecuDeTuplas($sp$)}{\TADIF vacía?($sp$)
                                 THEN \secuencia{}
                                 ELSE \secuencia{$\langle$prim($sp$)\DRef nombre{, }prim($sp$)\DRef id$\rangle$}[fin($sp$)]
                                 FI}

  ~

\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearÁrbol}{\In{raiz}{categoria}}{estr\_acat}{$\Theta(|raiz|)$}{
    $\Theta(1) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(|raiz| + copy(estr\_raiz)) + \Theta(1) =$ \\
    $5 * \Theta(1) + \Theta(|raiz| + copy(estr\_raiz)) =$ \\
    $\Theta(|raiz| + copy(estr\_raiz)) =$ \\
    $\Theta(|raiz|) + \Theta(copy(estr\_raiz)) =$ \\
    $\Theta(|raiz|) + \Theta(|raiz|) =$ \\
    $\Theta(|raiz|).$ 
  }
    \STATE \CrearTupla{var $estr\_raiz$: \TipoVariable{estr\_cat}}\CampoTupla{id}{1},                                  \CompTheta{1}
    \STATE \MargenTupla                                           \CampoTupla{nombre}{$raiz$},                         \CompTheta{1}
    \STATE \MargenTupla                                           \CampoTupla{hijos}{\NombreFuncion{Vacío}()}\FinTupla \CompTheta{1}
    \STATE var $categorias$: \TipoVariable{dicctrie(estr\_cat)} $\leftarrow$ \NombreFuncion{CrearDiccionario}() \CompTheta{1}
    \STATE \NombreFuncion{Definir}($raiz$, $estr\_raiz$, $categorias$) \CompTheta{$|raiz| + copy(estr\_raiz)$}
    \STATE \CrearTupla{$res$}\CampoTupla{raíz}{$estr\_raiz$}, %
                             \CampoTupla{categorías}{$categorias$}%
                             \FinTupla \CompTheta{1}  
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iNombreCategoríaRaíz}{\In{ac}{estr\_acat}}{categoria}{$\Theta(1)$}{}
  \STATE $res$ $\leftarrow$ $ac$.raíz.nombre \CompTheta{1}
  \end{Algoritmo}  

  ~
  
  \begin{Algoritmo}{iAgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{estr\_acat}}{}{$\Theta(|padre| + |hija|)$}{
    $\Theta(|padre|) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(|hija| + copy(estr\_hija)) + \Theta(|hija|) + \Theta(1) =$ \\
    $\Theta(|padre|) + \Theta(|hija| + copy(estr\_hija)) + \Theta(|hija|) =$ \\
    $\Theta(|padre|) + \Theta(|hija|) + \Theta(copy(estr\_hija)) + \Theta(|hija|) =$ \\
    $\Theta(|padre|) + 2 * \Theta(|hija|) + \Theta(copy(estr\_hija)) =$ \\
    $\Theta(|padre|) + 2 * \Theta(|hija|) + \Theta(|hija|) =$ \\
    $\Theta(|padre|) + 3 * \Theta(|hija|) =$ \\
    $\Theta(|padre|) + \Theta(|hija|) =$ \\
    $\Theta(|padre| + |hija|).$
  }
    \STATE var $estr\_padre$: \TipoVariable{estr\_cat} $\leftarrow$ \NombreFuncion{Obtener}($padre$, $ac$.categorías) \CompTheta{$|padre|$}
    \STATE \CrearTupla{var $estr\_hija$: \TipoVariable{estr\_cat}}\CampoTupla{id}{\NombreFuncion{\#Claves}($ac$.categorías) + 1}, \CompTheta{1}
    \STATE \MargenTupla                                           \CampoTupla{nombre}{$hija$}, \CompTheta{1}
    \STATE \MargenTupla                                           \CampoTupla{hijos}{\NombreFuncion{Vacío}()}\FinTupla \CompTheta{1}
    \STATE \NombreFuncion{Definir}($hija$, $estr\_hija$, $ac$) \CompTheta{$|hija| + copy(estr\_hija)$}     
    \STATE $estr\_hija$ $\leftarrow$ \NombreFuncion{Obtener}($hija$, $ac$.categorías) \CompTheta{$|hija|$}
    \STATE \NombreFuncion{AgregarRápido}($estr\_padre$.hijos, \&($estr\_hija$)) \CompTheta{1}
  \end{Algoritmo}

  ~   

  \begin{Algoritmo}{iIdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{estr\_acat}}{nat}{$\Theta(|c|)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Obtener}($c$, $ac$.categorías).id \CompTheta{|c|}
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{i\#Categorías}{\In{ac}{estr\_acat}}{nat}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{\#Claves}($ac$.categorías) \CompTheta{1}
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearIt}{\In{padre}{categoria}, \In{ac}{acat}}{itConj(puntero(estr\_cat))}{$\Theta(|padre|)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Obtener}($padre$, $ac$.categorías).hijos) \CompTheta{|padre|}
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearItRaíz}{\In{ac}{acat}}{itConj(puntero(estr\_cat))}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}($ac$.raíz.hijos) \CompTheta{1}
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iCrearItDadoOtroIt}{\In{it}{itConj(puntero(estr\_cat))}}{itConj(puntero(estr\_cat))}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Siguiente}(it)\DRef hijos) \CompTheta{1}
  \end{Algoritmo}  

  ~  
  
  \begin{Algoritmo}{iHayMás?}{\In{it}{itConj(puntero(estr\_cat))}}{bool}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$) \CompTheta{1}
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCategoríaActual}{\In{it}{itConj(puntero(estr\_cat))}}{categoria}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$)\DRef nombre \CompTheta{1}
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iIdCategoríaActual}{\In{it}{itConj(puntero(estr\_cat))}}{nat}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$)\DRef id \CompTheta{1}
  \end{Algoritmo}  
  
  ~
  
  \begin{Algoritmo}{iAvanzar}{\Inout{it}{itConj(puntero(estr\_cat))}}{}{$\Theta(1)$}{}
    \STATE \NombreFuncion{Avanzar}($it$) \CompTheta{1}
  \end{Algoritmo}

\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LinkLinkIt                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Módulo LinkLinkIt}

\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{LinkLinkIt}, \tadNombre{Iterador Unidireccional(Link)}.

  \textbf{géneros}: \TipoVariable{sistema}, \TipoVariable{itlinks}.

  \Titulo{Operaciones básicas del sistema}
  
  \InterfazFuncion{CrearSistema}{\In{ac}{acat}}{sistema}
  {$res$ $\igobs$ iniciar($ac$)}
  [$\Theta$(\#(categorías($ac$))]
  [crea un sistema cuyo árbol de categorías es $ac$.]

  \InterfazFuncion{AgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $¬$($l$ $\in$ links($s$)) $\land$ está?($c$, categorías($s$)]
  {$s$ $\igobs$ nuevoLink($s_{0}$, $l$, $c$)}
  [$\Theta$(|$l$| + |$c$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [agrega al sistema el link $l$ con categoría $c$.]

  \InterfazFuncion{AccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $l$ $\in$ links($s$) $\land$ $f$ $\geq$ fechaActual($s$)]
  {$s$ $\igobs$ acceso($s_{0}$, $l$, $f$)}
  [$\Theta$(|$l$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [registra un acceso al link $l$ en la fecha $f$.]

  \InterfazFuncion{\#Links}{\In{c}{categoría}, \In{s}{sistema}}{nat}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ cantLinks($s$, $c$)}
  [$\Theta$(|$c$|)]
  [devuelve la cantidad de links bajo la categoría $c$ y todas sus subcategorías.]

  \Titulo{Operaciones de iterador de links}

  \InterfazFuncion{CrearIt}{\In{c}{categoría}, \In{s}{sistema}}{itlinks}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ CrearItUni(tuplasLinks($c$, $s$)) $\land$ alias(iteraLinksCorrectos($res$, $c$, $s$))}  
  [$\Theta$(|$c$| + $n^2$), donde $n$ representa long(linksOrdenadosPorAccesos($s$, $c$)).]
  [devuelve un iterador unidireccional de los links de la categoría $c$ y todas sus subcategorías ordenados de mayor a menor cantidad de accesos recientes.]
  [El iterador podrá invalidarse si se agregan links a la categoría $c$ o alguna subcategoría y/o si se registran accesos a links de dichas categorías.]  
   
  \InterfazFuncion{HayMás?}{\In{it}{itlinks}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{LinkActual}{\In{it}{itlinks}}{link}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_1$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve el link actual del iterador.]
  [$res$ no es modificable.]

  \InterfazFuncion{CategoríaLinkActual}{\In{it}{itlinks}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_2$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve la categoría del link actual del iterador.]
  [$res$ no es modificable.]

  \InterfazFuncion{AccesosRecientesLinkActual}{\In{it}{itlinks}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_3$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve la cantidad de accesos del link actual del iterador durante los días de la intersección
   entre los tres días ``recientes'' del link $l$ y los tres días ``recientes'' del link que tuvo
   último acceso entre los links de la categoría $c$ con la que se creó este iterador, y los links
   de todas sus subcategorías.]

  \InterfazFuncion{Avanzar}{\Inout{it}{itlinks}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$it$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]  

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  {
    \offinterlineskip
    \begin{tad}{\tadNombre{Sistema Extendido}}
      \tadExtiende{\tadNombre{LinkLinkIt}}

      \tadTitulo{otras operaciones (no exportadas)}{}

      \tadOperacion{tuplasLinks}{categoría/c,lli/s}{secu(tupla(link{, }categoría{, }nat))}{está?($c$, categorías($s$))}
      \tadOperacion{linksATuplas}{secu(link)/sl,categoría/c,lli/s}{secu(tupla(link{, }categoría{, }nat))}{estánEnSistema?($sl$, $s$) $\land$ está?($c$, categorías($s$))}
      \tadOperacion{estánEnSistema?}{secu(link),link}{bool}{}
      \tadOperacion{iteraLinksCorrectos}{itUni(tupla(link{, }categoría{, }nat)),categoría/c,lli/s}{bool}{está?($c$, categorías($s$))}
      \tadOperacion{terminanIgual}{secu(tupla(link{, }categoría{, }nat)),secu(tupla(link{, }categoría{, }nat))}{bool}{}

      \tadAxiomas[\paratodo{categoría}{c}, \paratodo{lli}{s}, \paratodo{secu(link)}{sl}, \paratodo{itUni(tupla(link, categoría, nat))}{it},\\
                  \paratodo{secu(tupla(link, categoría, nat))}{st, st'}]  
  
      \tadAlinearAxiomas{iteraLinksCorrectos($it$, $c$, $s$)}
      \tadAxioma{tuplasLinks($c$, $s$)}{linksATuplas(linksOrdenadosPorAccesos($s$, $c$), $c$, $s$)}
      \tadAxioma{linksATuplas($sl$, $c$, $s$)}{\TADIF vacía?($sl$)
                                               THEN \secuencia{}
                                               ELSE \secuencia{$\langle$prim($sl$){, }
                                                                        categoríaLink($s${, }prim($sl$)){, }
                                                                        accesosRecientes($s${, }$c${, }prim($sl$))$\rangle$}
                                                              [linksATuplas(fin($sl$), $c$, $s$)]
                                               FI}
      \tadAxioma{estánEnSistema?($sl$, $s$)}{\TADIF vacía($sl$)
                                             THEN \textbf{true}
                                             ELSE prim($sl$) $\in$ links($s$) $\land$ estánEnSistema?(fin($sl$), $s$)
                                             FI}
    \tadAxioma{iteraLinksCorrectos($it$, $c$, $s$)}{terminanIgual(Siguientes($it$), tuplasLinks($c$, $s$))}
      \tadAxioma{terminanIgual($st$, $st'$)}{\TADIF vacía?($st$) $\lor$ vacía?($st'$)
                                             THEN \textbf{true}
                                             ELSE ult($st$) $\igobs$ ult($st'$) $\land$ terminanIgual(com($st$), com($st'$))
                                             FI}
    \end{tad}
  }
  
\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación del sistema}
  
  \begin{Estructura}{sistema}[estr\_sistema]
    \begin{Tupla}[estr\_sistema]
      \tupItem{categorías}{acat},\\
      \tupItem{links}{dicctrie(estr\_link)},\\
      \tupItem{linksPorCatId}{arreglo\_dimensionable de estr\_linksPorCatId},\\
      \tupItem{fechaActual}{fecha}%
    \end{Tupla}
    
    \begin{Tupla}[estr\_link]
      \tupItem{l}{link},\\
      \tupItem{cid}{nat},\\
      \tupItem{últimoAcceso}{fecha},\\
      \tupItem{as}{arreglo\_estático[3] de fecha}%
    \end{Tupla}
    
    \begin{Tupla}[estr\_linksPorCatId]
      \tupItem{cat}{categoria},\\
      \tupItem{idPadre}{nat},\\
      \tupItem{links}{lista(puntero(estr\_link))},\\
      \tupItem{últimoAcceso}{fecha},\\
      \tupItem{ordenado?}{bool}%            
    \end{Tupla}    
  \end{Estructura}
  
  \textbf{Invariante de representación:}

  \begin{enumerate}
    \item Para todos los links en el diccionario de links:
    \begin{enumerate}
      \item El nombre del link debe coincidir con la clave.
      \item El id de su categoría debe corresponderse con el id de una categoría en el árbol.
      \item La fecha del último acceso debe ser menor o igual a la fecha actual del sistema.
    \end{enumerate}
    \item $linksPorCatId$ debe tener tantos elementos como categorías hayan en el árbol.
    \item Para cada elemento en $linksPorCatId$:
    \begin{enumerate}
      \item La categoría debe estar en el árbol.
      \item El índice del elemento debe ser igual al id de la categoría en el árbol $-$ $1$.
      \item $idPadre$ debe ser igual al id del padre de la categoría en el árbol,
            o cero si la categoría es la raíz.
      \item La lista de punteros de estr\_link no puede tener elementos repetidos.
      \item Para cada elemento en la lista de punteros de estr\_link:
      \begin{enumerate}
        \item El elemento no puede ser un puntero nulo.
        \item El elemento tiene que apuntar a un link en el diccionario de links.
        \item El elemento tiene que estar en la lista de links del elemento en la posición
              $idPadre - 1$ del arreglo $linksPorCatId$, a menos que $idPadre$ sea cero.
      \end{enumerate}
      \item La fecha del último acceso debe ser menor o igual a la fecha actual del sistema.
    \end{enumerate}
    \item Al menos un link en el diccionario de links tiene como fecha de último acceso
          la fecha actual del sistema.
  \end{enumerate}

  \Rep[estr\_sistema][s]{\\
    ($\forall l$: link)(def?($l$, $s$.links) $\impluego$ ( \hfill 1. \\
      \margen $estr\_l$.l $\igobs$ $l$ $\land$ \hfill 1. a) \\
      \margen ($\exists c$: categoría)(está?($c$, $s$.categorías) $\yluego$ $estr\_l$.cid $\igobs$ id($s$.categorías. $c$)) $\land$ \hfill 1. b) \\
      \margen $estr\_l$.últimoAcceso $\leq$ $s$.fechaActual \hfill 1. c) \\
    )) $\land$ \\
    tam($s$.linksPorCatId) $\igobs$ \#(categorias($s$.categorías)) $\land$ \hfill 2. \\
    ($\forall i$: nat)($i$ $<$ tam($s$.linksPorCatId) $\impluego$ ( \hfill 3. \\
      \margen está?($estr\_c$.cat, $s$.categorías) $\yluego$ \hfill 3. a) \\
      \margen $i$ $\igobs$ id($s$.categorías, $estr\_c$.cat) $-$ $1$ $\land$ \hfill 3. b) \\
      \margen $estr\_c$.idPadre $\igobs$ \hfill 3. c) \\
        \margen\margen (\textbf{if} $estr\_c$.cat $\igobs$ raíz($s$.categorías) \\
        \margen\margen \phantom{(}\textbf{then} $0$ \\
        \margen\margen \phantom{(}\textbf{else} id($s$.categorías, padre($s$.categorías, $estr\_c$.cat)) \\
        \margen\margen \phantom{(}\textbf{fi}) $\land$ \\
      \margen SinRepetidos($estr\_c$.links) $\land$ \hfill 3. d) \\
      \margen ($\forall l$: puntero(estr\_link))(está?($l$, $estr\_c$.links) $\impluego$ ( \hfill 3. e) \\
        \margen\margen $¬$($l$ $\igobs$ NULL) $\yluego$ \hfill 3. e) 1) \\
        \margen\margen def?($l$\DRef l, $s$.links) $\yluego$ $l$ $\igobs$ \&(obtener($l$\DRef l, $s$.links)) $\land$ \hfill 3. e) 2) \\
        \margen\margen $¬$($estr\_c$.idPadre $\igobs$ 0) $\impluego$ está?($l$, $s$.linksPorCatId[$estr\_c$.idPadre $-$ $1$].links) \hfill 3. e) 3) \\
      \margen )) $\land$ \\
      \margen $estr\_c$.últimoAcceso $\leq$ $s$.fechaActual \hfill 3. f) \\
    )) $\land$ \\
    ($\exists l$: link)(def?($l$, $s$.links) $\yluego$ obtener($l$, $s$.links).últimoAcceso $\igobs$ $s$.fechaActual), \hfill 4. \\
    donde $estr\_l$ es obtener($l$, $s$.links) y $estr\_c$ es $s$.linksPorCatId[$i$].
  }

  \mbox{}
  
  ~
  
  \tadOperacion{SinRepetidos}{secu(puntero(estr\_link))}{bool}{}
  \tadAxioma{SinRepetidos($sp$)}{\TADIF vacía?($sp$)
                                 THEN \textbf{true}
                                 ELSE $¬$(está?(prim($sp$), fin($sp$))) $\land$ SinRepetidos(fin($sp$))
                                 FI}
                                 
  ~
  
  \textbf{Función de abstracción:}
  
  \begin{enumerate}
    \item El árbol de categorías del sistema debe ser igual al de la estructura.
    \item El conjunto de links del sistema debe ser igual al conjunto de clave del diccionario de links de la estructura.
    \item La fecha actual del sistema debe ser igual a la fecha actual de la estructura.
    \item Para cada link en el sistema:
    \begin{enumerate}
      \item La categoría del link en el sistema debe ser igual a la categoría del link en el diccionario de la estructura.
      \item La fecha de último acceso del link en el sistema debe ser igual a la fecha de último acceso del link en el diccionario de la estructura.
      \item Los accesos recientes por día del link en el sistema deben coincidir con los elementos del arreglo de accesos recientes del link
            en el diccionario de la estructura.
    \end{enumerate}
  \end{enumerate}

  \Abs[estr\_sistema]{lli}[e]{s}{%
    categorias($s$) $\igobs$ $e$.categorías $\land$ \hfill 1. \\
    links($s$) $\igobs$ claves($e$.links) $\land$ \hfill 2. \\
    fechaActual($s$) $\igobs$ $e$.fechaActual $\land$ \hfill 3. \\
    ($\forall l$: link)($l$ $\in$ links($s$) $\impluego$ ( \hfill 4. \\
      \margen categoriaLink($s$, $l$) $\igobs$ $s$.linksPorCatId[obtener($l$, $e$.links).cid $-$ $1$].cat $\land$ \hfill 4. a) \\
      \margen fechaUltimoAcceso($s$, $l$) $\igobs$ obtener($l$, $e$.links).últimoAcceso $\land$ \hfill 4. b) \\
      \margen MismosAccesos($l$, $s$, $e$) \hfill 4. c) \\
    ))
  }
  
  ~
  
  \tadOperacion{MismosAccesos}{link/l,lli/s,estr\_sistema/e}{bool}{$l$ $\in$ links($s$) $\land$ def?($l$, $e$.links)}
  \tadAxioma{MismosAccesos($l$, $s$, $e$)}{
    ($\forall n$: nat)($n$ $\leq$ 2 $\impluego$ \\
      \margen accesosRecientesDia($s$, $l$, fechaUltimoAcceso($s$, $l$) $-$ $n$) $\igobs$ \\
      \margen obtener($l$, $e$.links).as[$n$])
  }
  
  ~
  
  ~
  
  \Titulo{Representación del iterador}  
  
  \begin{Estructura}{itlinks}[estr\_iter]
    \begin{Tupla}[estr\_iter]
      \tupItem{s}{estr\_sistema},
      \tupItem{cid}{nat},
      \tupItem{it}{itLista(puntero(estr\_link))}%
    \end{Tupla}
  \end{Estructura}

  ~

  \textbf{Invariante de representación:}

  \begin{enumerate}
    \item $s$ representa un sistema válido.
    \item $cid$ debe ser el id de una categoría en el sistema.
    \item La secuencia subyacente del iterador debe ser la secuencia de links en la categoría
          con id $cid$ y sus subcategorías.
  \end{enumerate}

  \Rep[estr\_iter][e]{ \\
    Rep($e$.s) $\land$ \hfill 1. \\
    1 $\leq$ $e$.cid $\land$ $e$.cid $\leq$ \#(categorias($e$.s.categorías)) $\land$ \hfill 2. \\
    SecuSuby($e$.it) $\igobs$ $e$.s.linksPorCatId[$e$.cid $-$ $1$].links \hfill 3.
  }

  \mbox{}

  ~

  \textbf{Función de abstracción:}
  
  \begin{enumerate}
    \item Los elementos siguientes del iterador deben ser las tuplas (link, categoría, nat) que se correspondan
          con los elementos siguientes del iterador de la estructura.
  \end{enumerate}

  \Abs[estr\_iter]{itUni(tupla(link, categoría, nat))}[e]{it}{%
    Siguientes($it$) $\igobs$ SecuDeTuplas( \hfill 1. \\
      \margen Abs($e$.s), \\
      \margen $e$.s.linksPorCatId[$e$.cid $-$ 1].cat, \\
      \margen SecuDeLinks(Siguientes($e$.it)))
  }

  ~
  
  \tadOperacion{SecuDeTuplas}{lli/s,categoria/c,secu(link)/sl}
               {secu(tupla(link, categoria, nat))}
               {está?($c$, categorias($s$)) $\land$ EstánEnConj?($sl$, links($s$))}
  \tadAxioma{SecuDeTuplas($s$, $c$, $sl$)}{\TADIF vacía?($sl$)
                                           THEN \secuencia{}
                                           ELSE $\langle$prim($sl$), \\
                                                         \phantom{$\langle$}categoriaLink($s$, prim($sl$)), \\
                                                         \phantom{$\langle$}accesosRecientes($s$, $c$, prim($sl$))$\rangle$
                                                $\bullet$ SecuDeTuplas($s$, $c$, fin($sl$))
                                           FI}
  
  ~

  ~
    
  \tadOperacion{EstánEnConj?}{secu(link),conj(link)}{bool}{}
  \tadAxioma{EstánEnConj?($sl$, $cl$)}{\TADIF vacía?($sl$)
                                       THEN \textbf{true}
                                       ELSE prim($sl$) $\in$ $cl$ $\land$ EstánEnConj?(fin($sl$), $cl$)
                                       FI}
  
  ~

  \tadOperacion{SecuDeLinks}{secu(puntero(estr\_link))/sp}{secu(link)}{$¬$(está?(NULL, $sp$))}
  \tadAxioma{SecuDeLinks($sp$)}{\TADIF vacía?($sp$)
                                THEN \secuencia{}
                                ELSE \secuencia{prim($sp$)\DRef l}[SecuDeLinks(fin($sp$))]
                                FI}
  
  ~

\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearSistema}{\In{ac}{estr\_acat}}{estr\_sistema}{$\Theta(\#(categorias(ac)))$}{
    $12 * \Theta(1) + \Theta(\#categorias(ac)) + \Theta(\sum_{i=1}^{i=long(Siguientes(it))}{\#subcategorias(Siguientes(it)_i)}) =$ \\
    $\Theta(\#categorias(ac)) + \Theta(\sum_{i=1}^{i=long(Siguientes(it))}{\#subcategorias(Siguientes(it)_i)}) =$ \\
    $\Theta(\#categorias(ac)) + \Theta(\#categorias(ac) - 1) =$ \\
    $\Theta(\#categorias(ac)).$ \\
    \\
    Notar que $\sum_{i=1}^{i=long(Siguientes(it))}{\#subcategorias(Siguientes(it)_i)} = \#categorias(ac) - 1$.
  }
    \STATE \CrearTupla{$res$}\CampoTupla{categorías}{$ac$}, \CompTheta{1}
    \STATE \MargenTupla      \CampoTupla{links}{\NombreFuncion{CrearDiccionario}()}, \CompTheta{1}
    \STATE \MargenTupla      \CampoTupla{linksPorCatId}{\NombreFuncion{CrearArreglo}(\NombreFuncion{\#Categorías}($ac$))}, \CompTheta{$\#categorias(ac)$}
    \STATE \MargenTupla      \CampoTupla{fechaActual}{0}\FinTupla \CompTheta{1}
    \STATE \CrearTupla{$res$.linksPorCatId[0]}\CampoTupla{cat}{\NombreFuncion{NombreCategoríaRaíz}($ac$)}, \CompTheta{1}
    \STATE \MargenTupla                       \CampoTupla{idPadre}{0}, \CompTheta{1}
    \STATE \MargenTupla                       \CampoTupla{links}{\NombreFuncion{Vacía}()}, \CompTheta{1}
    \STATE \MargenTupla                       \CampoTupla{últimoAcceso}{0}, \CompTheta{1}
    \STATE \MargenTupla                       \CampoTupla{ordenado?}{\textbf{false}}\FinTupla \CompTheta{1}
    \STATE var $it$: \TipoVariable{itcats} $\leftarrow$ \NombreFuncion{CrearItRaíz}($ac$) \CompTheta{1}
    \STATE \NombreFuncion{iAgregarALinksPorCatId}( \CompTheta{$\sum_{i=1}^{i=long(Siguientes(it))}{\#subcategorias(Siguientes(it)_i)}$}
    \STATE   \margen $it$, \CompTheta{1}
    \STATE   \margen 1, \CompTheta{1}
    \STATE   \margen $res$)  \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAgregarALinksPorCatId}{\Inout{it}{itcats}, \In{idPadre}{nat}, \Inout{s}{estr\_sistema}}{}{
    $\Theta(\sum_{i=1}^{i=long(Siguientes(it))}{\#subcategorias(Siguientes(it)_i)})$, donde:\\
      \margen$\bullet$ $\#subcategorias(x)$ es la cantidad de nodos del subárbol de categorías en el cual $x$ es el nodo raíz, y \\
      \margen$\bullet$ $Siguientes(it)_i$ es el $i$-ésimo elemento de la secuencia de elementos siguientes del iterador $it$.
  }
  {
    El algoritmo recibe un iterador de categorías, y para cada una de ellas guarda información en la posición correspondiente
    en el arreglo $s$.linksPorCatId, y luego crea un iterador de sus categorías hijas que utiliza para llamarse recursivamente.
  }
    \WHILE{\NombreFuncion{HayMás?}($it$)}
      \STATE \CrearTupla{$s$.linksPorCatId[\NombreFuncion{IdCategoríaActual}($it$) - 1]}%
                          \CampoTupla{cat}{\NombreFuncion{CategoríaActual}($it$)},  \CompTheta{1}
      \STATE \MargenTupla \CampoTupla{idPadre}{$idPadre$},  \CompTheta{1}
      \STATE \MargenTupla \CampoTupla{links}{\NombreFuncion{Vacía}()},  \CompTheta{1}
      \STATE \MargenTupla \CampoTupla{últimoAcceso}{0},  \CompTheta{1}
      \STATE \MargenTupla \CampoTupla{ordenado?}{\textbf{false}}\FinTupla  \CompTheta{1}
      \STATE var $it'$: \TipoVariable{itcats} $\leftarrow$ \NombreFuncion{CrearItDadoOtroIt}($it$)  \CompTheta{1}
      \STATE \NombreFuncion{iAgregarALinksPorCatId}(  \CompTheta{$\sum_{i=1}^{i=long(Siguientes(it'))}{\#subcategorias(Siguientes(it')_i)}$}
      \STATE   \margen$ithijos$, \CompTheta{1}
      \STATE   \margen\NombreFuncion{IdCategoríaActual}($it$), \CompTheta{1}
      \STATE   \margen$s$) \CompTheta{1}
      \STATE \NombreFuncion{Avanzar}($it$) \CompTheta{1}
    \ENDWHILE
  \end{Algoritmo}
    
  ~  
  
  \begin{Algoritmo}{iAgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{estr\_sistema}}{}{
    $\Theta(|c| + |l| + h)$, donde $h$ es la altura del árbol de categorías.
  }
  {
    $\Theta(1) + \Theta(|c|) + \Theta(1) + \Theta(1) + \Theta(|l| + copy(estr\_l)) + \Theta(|l|) + \Theta(1)\ +$ ciclo $=$ \\
    $4 * \Theta(1) + \Theta(|c|) + \Theta(|l| + copy(estr\_l))\ +$ ciclo $=$ \\
    $\Theta(|c|) + \Theta(|l| + copy(estr\_l))\ +$ ciclo $=$ \\
    $\Theta(|c|) + \Theta(|l|) + \Theta(copy(estr\_l))\ +$ ciclo $=$ \\    
    $\Theta(|c|) + \Theta(|l|) + \Theta(|c|)\ +$ ciclo $=$ \\
    $2 * \Theta(|c|) + \Theta(|l|)\ +$ ciclo $=$ \\
    $\Theta(|c|) + \Theta(|l|)\ +$ ciclo $=$ \\
    $\Theta(|c|) + \Theta(|l|)\ + h * (\Theta(1) + \Theta(1) + \Theta(1)) =$ \\
    $\Theta(|c|) + \Theta(|l|)\ + h * (3 * \Theta(1)) =$ \\
    $\Theta(|c|) + \Theta(|l|)\ + h * \Theta(1) =$ \\
    $\Theta(|c| + |l| + h).$
  }
    \STATE \CrearTupla{var $estr\_l$: \TipoVariable{estr\_link}}%
                        \CampoTupla{l}{$l$}, \CompTheta{1}
    \STATE \MargenTupla \CampoTupla{cid}{\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías)}, \CompTheta{$|c|$}
    \STATE \MargenTupla \CampoTupla{últimoAcceso}{$s$.fechaActual},  \CompTheta{1}
    \STATE \MargenTupla \CampoTupla{as}{\NombreFuncion{iCrearArregloDe3Nats}(0, 0, 0)}\FinTupla \CompTheta{1}
    \STATE \NombreFuncion{Definir}($l$, $estr\_l$, $s$.links) \CompTheta{$|l| + copy(estr\_l)$}
    \STATE $estr\_l$ $\leftarrow$ \NombreFuncion{Obtener}($l$, $s$.links) \CompTheta{$|l|$}
    \STATE
    \STATE var $cid$: \TipoVariable{nat} $\leftarrow$ $estr\_l$.cid \CompTheta{1}
    \WHILE{$¬$($cid$ $\igobs$ 0)}
      \STATE \NombreFuncion{AgregarAtrás}($s$.linksPorCatId[$cid$ - 1].links, \&($estr\_l$)) \CompTheta{1}
      \STATE $s$.linksPorCatId[$cid$ - 1].últimoAcceso $\leftarrow$ $s$.fechaActual \CompTheta{1}
      \STATE $s$.linksPorCatId[$cid$ - 1].ordenado? $\leftarrow$ \textbf{false} \CompTheta{1}
      \STATE $cid$ $\leftarrow$ $s$.linksPorCatId[$cid$ - 1].idPadre \CompTheta{1}
    \ENDWHILE
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{estr\_sistema}}{}{
    $\Theta(|l| + h)$, donde $h$ es la altura del árbol de categorías.
  }
  {
    $\Theta(|l|) + \Theta(1) + \Theta(1) + \Theta(1) + h * (\Theta(1) + \Theta(1) + \Theta(1)) =$ \\
    $\Theta(|l|) + 3 * \Theta(1) + h * (\Theta(1) + \Theta(1) + \Theta(1)) =$ \\
    $\Theta(|l|) + h * (\Theta(1) + \Theta(1) + \Theta(1)) =$ \\
    $\Theta(|l|) + h * (3 * \Theta(1)) =$ \\
    $\Theta(|l|) + h =$ \\
    $\Theta(|l| + h)$.
  }
    \STATE var $estr\_l$: \TipoVariable{estr\_link} $\leftarrow$ \NombreFuncion{Obtener}($l$, $s$.links) \CompTheta{$|l|$}
    \IF{$f$ $\igobs$ $estr\_l$.últimoAcceso}
      \STATE $estr\_l$.as[0] $\leftarrow$ $estr\_l$.as[0] + 1 \CompTheta{1}
    \ELSIF{$f$ $\igobs$ $estr\_l$.últimoAcceso + 1}
      \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, $estr\_l$.as[0], $estr\_l$.as[1]) \CompTheta{1}
    \ELSIF{$f$ $\igobs$ $estr\_l$.últimoAcceso + 2}
      \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, 0, $estr\_l$.as[0]) \CompTheta{1}
    \ELSE
      \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, 0, 0) \CompTheta{1}
    \ENDIF
    \STATE
    \STATE $s$.fechaActual $\leftarrow$ $f$ \CompTheta{1}
    \STATE
    \STATE var $cid$: \TipoVariable{nat} $\leftarrow$ $estr\_l$.cid \CompTheta{1}
    \WHILE{$¬$($cid$ $\igobs$ 0)}
      \STATE $s$.linksPorCatId[$cid$ - 1].últimoAcceso $\leftarrow$ $s$.fechaActual \CompTheta{1}
      \STATE $s$.linksPorCatId[$cid$ - 1].ordenado? $\leftarrow$ \textbf{false} \CompTheta{1}
      \STATE $idPadre$ $\leftarrow$ $s$.linksPorCatId[$cid$ - 1].idPadre \CompTheta{1}
    \ENDWHILE     
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCrearArregloDe3Nats}{\In{a}{nat}, \In{b}{nat}, \In{c}{nat}}{arreglo\_estático[3] de nat}{$\Theta(1)$}{}
    \STATE $\res$ $\leftarrow$ \NombreFuncion{CrearArreglo}() \CompTheta{1}
    \STATE $\res$[0] $\leftarrow$ $a$ \CompTheta{1}
    \STATE $\res$[1] $\leftarrow$ $b$ \CompTheta{1}
    \STATE $\res$[2] $\leftarrow$ $c$ \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{i\#Links}{\In{c}{categoría}, \In{s}{estr\_sistema}}{nat}{$\Theta(|c|)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Longitud}($s$.linksPorCatId[\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías) - 1].links) \CompTheta{|c|}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iCrearIt}{\In{c}{categoría}, \In{s}{estr\_sistema}}{estr\_iter}{
    $\Theta(|c| + n^2)$ ó $\Theta(|c|)$, donde $n$ es la cantidad de links de $c$ y todas sus subcategorías.
  }
  {
    $\Theta(1) + \Theta(|c|) + (\Theta(|estr\_c$.links$|^2)$ ó $0) + \Theta(1) + \Theta(|c|) + \Theta(1) =$ \\
    $3 * \Theta(1) + \Theta(|c|) + (\Theta(|estr\_c$.links$|^2)$ ó $0) + \Theta(|c|) =$ \\
    $\Theta(|c|) + (\Theta(|estr\_c$.links$|^2)$ ó $0) + \Theta(|c|) =$ \\
    $2 * \Theta(|c|) + (\Theta(|estr\_c$.links$|^2)$ ó $0) =$ \\
    $\Theta(|c|) + (\Theta(|estr\_c$.links$|^2)$ ó $0) =$ \\
    $\Theta(|c|) + (\Theta(n^2)$ ó $0) =$ \\
    $\Theta(|c|) + (n^2$ ó $0) =$ \\    
    $\Theta(|c| + n^2)$ ó $\Theta(|c|)$. \\
    \\
    Notar que $n =\ $estr\_c$.links$.
  }
    \STATE var $estr\_c$: \TipoVariable{estr\_linksPorCatId} $\leftarrow$ $s$.linksPorCatId[ \CompTheta{1}
    \STATE   \margen \NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías) - 1] \CompTheta{|c|}
    \IF{$¬$($estr\_c$.ordenado?)}
      \STATE \NombreFuncion{iOrdenarLinks}($estr\_c$) \CompTheta{$|estr\_c$.links$|^2$}
    \ENDIF
    \STATE \CrearTupla{$res$}\CampoTupla{s}{$s$}, \CompTheta{1}
    \STATE \MargenTupla      \CampoTupla{cid}{\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías)}, \CompTheta{$|c|$}
    \STATE \MargenTupla      \CampoTupla{it}{\NombreFuncion{CrearIt}($estr\_c$.links)}\FinTupla \CompTheta{1}
  \end{Algoritmo}  
  
  ~
  
  \begin{Algoritmo}{iOrdenarLinks}{\In{estr\_c}{estr\_linksPorCatId}}{}{
    $\Theta(n^2)$, donde $n$ es $|estr\_c$.links$|$.
  }
  {
    $\Theta(1) + (\sum_{i=1}^{i=n} \sum_{j=i}^{j=n} \Theta(1)) =$ \\
    $\Theta(1) + \Theta(1) * (\sum_{i=1}^{i=n} \sum_{j=i}^{j=n} 1) =$ \\
    $\Theta(1) + \Theta(1) * (\sum_{i=1}^{i=n} n - i) =$ \\
    $\Theta(1) + \Theta(1) * (n^2 + (\sum_{i=1}^{i=n} - i)) =$ \\
    $\Theta(1) + \Theta(1) * (n^2 - (\sum_{i=1}^{i=n} i)) =$ \\
    $\Theta(1) + \Theta(1) * (n^2 - \frac{1}{2} * (n * (n - 1))) =$ \\
    $\Theta(1) + \Theta(1) * (n^2 - \frac{1}{2} * (n^2 - n)) =$ \\    
    $\Theta(1) + \Theta(n^2 - \frac{1}{2} * (n^2 - n)) =$ \\
    $\Theta(1) + \Theta(n^2 - \frac{1}{2} * n^2 - \frac{1}{2} * n)) =$ \\    
    $\Theta(1) + \Theta(n^2) - \frac{1}{2} * \Theta(n^2) - \frac{1}{2} * \Theta(n) =$ \\
    $\Theta(1) + \frac{1}{2} * \Theta(n^2) - \frac{1}{2} * \Theta(n) =$ \\    
    $\Theta(n^2)$.  
  }
    \STATE var $it$: \TipoVariable{itLista(puntero(estr\_link))} $\leftarrow$ \NombreFuncion{CrearIt}($estr\_c$.links) \CompTheta{1}
    \WHILE{\NombreFuncion{HaySiguiente}($it$)}
      \STATE var $it'$: \TipoVariable{itLista(puntero(estr\_link))} $\leftarrow$ \NombreFuncion{Copiar}($it$) \CompTheta{1}
      \STATE var $itMax$: \TipoVariable{itLista(puntero(estr\_link))} $\leftarrow$ \NombreFuncion{Copiar}($it'$) \CompTheta{1}
      \WHILE{\NombreFuncion{HaySiguiente}($it'$)}
        \STATE var $arActual$: \TipoVariable{nat} $\leftarrow$
               \NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Siguiente}($it'$), $estr\_c$) \CompTheta{1}
        \STATE var $arMax$: \TipoVariable{nat} $\leftarrow$
               \NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Siguiente}($itMax$), $estr\_c$) \CompTheta{1}
        \IF{$arActual > arMax$}
          \STATE $itMax$ $\leftarrow$ \NombreFuncion{Copiar}($it'$) \CompTheta{1}
        \ENDIF
    \STATE \NombreFuncion{Avanzar($it'$)} \CompTheta{1}
    \ENDWHILE
    \STATE \NombreFuncion{iIntercamabiar}($it$, $itMax$) \CompTheta{1}
      \STATE \NombreFuncion{Avanzar($it$)} \CompTheta{1}
    \ENDWHILE
    \STATE $estr\_c$.ordenado? $\leftarrow$ \textbf{true} \CompTheta{1}
  \end{Algoritmo}  
  
  ~  

  \begin{Algoritmo}{iAccesosRecientes}{\In{estr\_l}{estr\_link}, \In{estr\_c}{estr\_linksPorCatId}}{nat}{$\Theta(1)$}{}
    \IF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso}
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0] + $estr\_l$.as[1] + $estr\_l$.as[2] \CompTheta{1}
    \ELSIF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso + 1}
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0] + $estr\_l$.as[1] \CompTheta{1}
    \ELSIF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso + 2}          
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0] \CompTheta{1}
    \ELSE
      \STATE $res$ $\leftarrow$ 0 \CompTheta{1}
    \ENDIF
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iIntercambiar}{\Inout{it}{itLista(puntero(estr\_link))}, \Inout{it'}{itLista(puntero(estr\_link))}}{}{$\Theta(1)$}{
    $\Theta(1) + \Theta(1) + \Theta(copy(Siguiente(it))) + \Theta(1) + \Theta(copy(ptr)) =$ \\
    $3 * \Theta(1) + \Theta(copy(Siguiente(it))) + \Theta(copy(ptr)) =$ \\
    $3 * \Theta(1) + \Theta(1) + \Theta(copy(ptr)) =$ \\    
    $3 * \Theta(1) + \Theta(1) + \Theta(1) =$ \\
    $5 * \Theta(1) =$ \\ 
    $\Theta(1)$. \\
  }
    \STATE var $ptr$: \TipoVariable{puntero(estr\_link)} $\leftarrow$ \NombreFuncion{Siguiente}($it'$) \CompTheta{1}
    \STATE \NombreFuncion{EliminarSiguiente}($it'$) \CompTheta{1}
    \STATE \NombreFuncion{AgregarComoSiguiente}($it'$, \NombreFuncion{Siguiente}($it$)) \CompTheta{$copy(Siguiente(it))$}
    \STATE \NombreFuncion{EliminarSiguiente}($it$) \CompTheta{1}
    \STATE \NombreFuncion{AgregarComoSiguiente}($it$, $ptr$) \CompTheta{$copy(ptr)$}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iHayMás?}{\In{it}{estr\_iter}}{bool}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$.it) \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iLinkActual}{\In{it}{estr\_iter}}{link}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$.it)\DRef l \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iCategoríaLinkActual}{\In{it}{estr\_iter}}{categoria}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ $it$.s.linksPorCatId[\NombreFuncion{Siguiente}($it$.it)\DRef cid - 1].cat \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccesosRecientesLinkActual}{\In{it}{estr\_iter}}{nat}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ \NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Siguiente}($it$.iter), $it$.s.linksPorCatId[$it$.cid - 1]) \CompTheta{1}
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAvanzar}{\Inout{it}{estr\_iter}}{}{$\Theta(1)$}{}
    \STATE \NombreFuncion{Avanzar}($it$.it) \CompTheta{1}
  \end{Algoritmo}
  
\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diccionario Trie                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo Diccionario Trie($\alpha$)}

\begin{Interfaz}
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Diccionario(String, $\alpha$)}.

  \textbf{géneros}: \TipoVariable{dicctrie$(\alpha)$}.

  \Titulo{Operaciones básicas de diccionario trie}
  
  \InterfazFuncion{CrearDiccionario}{}{dicctrie$(\alpha)$}
  {$res$ $\igobs$ vacío()}
  [$\Theta(1)$]
  [crea un nuevo diccionario vacío.]

  \InterfazFuncion{Definir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{dicctrie$(\alpha)$}}{}
  [$d$ $\igobs$ $d_{0}$]
  {$d$ $\igobs$ definir($d_{0}$, $c$, $s$)}
  [$\Theta(|c| + copy(s))$]
  [define la clave $c$ con el significado $s$ en el diccionario.]
  [el significado $s$ se agrega por copia.]  
  
  \InterfazFuncion{Obtener}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{$\alpha$}
  [def?($c$, $d$)]
  {$res$ $\igobs$ obtener($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve el significado de la clave $c$ en $d$.]
  [$res$ es modificable si y sólo si $d$ es modificable.]
   
  \InterfazFuncion{\#Claves}{\In{d}{dicctrie$(\alpha)$}}{nat}
  {$res$ $\igobs$ \#(claves($d$))}
  [$\Theta(1)$]
  [devuelve la cantidad de claves del diccionario.]    

\end{Interfaz}

~

\begin{Representacion}

  \begin{Estructura}{dicctrie$(\alpha)$}[estr\_dicctrie]
    \begin{Tupla}[estr\_dicctrie]
      \tupItem{raíz}{estr\_nodo},\\
      \tupItem{\#Claves}{nat}%
    \end{Tupla}
   
    \begin{Tupla}[estr\_nodo]
      \tupItem{significado}{puntero$(\alpha)$},\\
      \tupItem{hijos}{arreglo\_estático[256] de puntero(estr\_nodo)}%
    \end{Tupla}
  \end{Estructura}
  
  \textbf{Invariante de representación:}

  \begin{enumerate}
    \item El árbol no debe tener ciclos.
    \item El árbol no debe tener nodos repetidos.
    \item Los nodos terminales tienen significado no nulo.
    \item La cantidad de claves debe coincidir con la cantidad de significados.
  \end{enumerate}

  \Rep[estr\_dicctrie][e]{ \\
    NoHayCiclos($e$.raíz, $\emptyset$) $\yluego$ \hfill 1. \\
    SinRepetidos(Aplanar($e$.raíz)) $\land$ \hfill 2. \\
    NodoTerminalTieneSignificado($e$.raíz) $\land$ \hfill 3. \\
    $e$.\#Claves $\igobs$ ContarSignificados($e$.raíz) \hfill 4.
  }
  
  \mbox{}

  ~
  
  \tadOperacion{NoHayCiclos}{estr\_nodo, conj(estr\_nodo)}{bool}{}
  \tadAxioma{NoHayCiclos($e$, $ancestros$)}{$¬$($e$ $\in$ $ancestros$) $\yluego$ NoHayCiclosEnLosHijos($e$, Ag($e$, $ancestros$), 0)}

  ~

  \tadOperacion{NoHayCiclosEnLosHijos}{estr\_nodo, conj(estr\_nodo), nat}{bool}{}
  \tadAxioma{NoHayCiclosEnLosHijos($e$, $ancestros$, $n$)}{
    ($¬$($e$.hijos[$n$] $\igobs$ NULL) $\impluego$ \\
      \margen NoHayCiclos(*($e$.hijos[$n$]), $ancestros$)) $\yluego$ \\
    ($n$ $<$ 255 $\impluego$ NoHayCiclosEnLosHijos($e$, $ancestros$, $n$ $+$ 1))
  }  
  
  ~
  
  ~
  
  \tadOperacion{Aplanar}{estr\_nodo/e}{secu(estr\_nodo)}{NoHayCiclos($e$, $\emptyset$)}
  \tadAxioma{Aplanar($e$)}{\secuencia{$e$} \& AplanarHijos($e$, 0)}
  
  ~

  \tadOperacion{AplanarHijos}{estr\_nodo/e,nat}{secu(estr\_nodo)}{NoHayCiclos($e$, $\emptyset$)}
  \tadAxioma{AplanarHijos($e$, $n$)}{
    (\TADIF e.hijos[$n$] $\igobs$ NULL
     THEN \secuencia{}
     ELSE Aplanar(*(e.hijos[$n$]))
     FI) \& \\
    (\TADIF $n$ $<$ 255
     THEN AplanarHijos($e$, $n$ $+$ 1)
     ELSE \secuencia{}
     FI)}
  
  ~

  ~  
  
  \tadOperacion{SinRepetidos}{secu(estr\_nodo)}{bool}{}
  \tadAxioma{SinRepetidos($sn$)}{\TADIF vacía?($sn$) THEN \textbf{true} ELSE $¬$(está?(prim($sn$), fin($sn$))) $\land$ SinRepetidos(fin($sn$)) FI}

  ~  
  
  \tadOperacion{NodoTerminalTieneSignificado}{estr\_nodo/e}{bool}{NoHayCiclos($e$, $\emptyset$)}
  \tadAxioma{NodoTerminalTieneSignificado($e$)}{\TADIF EsTerminal?($e$, 0)
                                                THEN $¬$(significado($e$) $\igobs$ NULL)
                                                ELSE NodoHijoTerminalTieneSignificado($e$, 0)
                                                FI}
  
  ~
  
  ~
  
  \tadOperacion{EsTerminal?}{estr\_nodo/e,nat}{bool}{}    
  \tadAxioma{EsTerminal?($e$, $n$)}{$e$.hijos[$n$] $\igobs$ NULL $\yluego$ ($n$ $<$ 255 $\impluego$ EsTerminal?($e$, $n$ $+$ 1))}  
  
  ~
  
  \tadOperacion{NodoHijoTerminalTieneSignificado}{estr\_nodo/e,nat}{bool}{NoHayCiclos($e$, $\emptyset$)}    
  \tadAxioma{NodoHijoTerminalTieneSignificado($e$, $n$)}{
    ($¬$($e$.hijos[$n$] $\igobs$ NULL) $\impluego$ \\
      \margen NodoTerminalTieneSignificado(*($e$.hijos[$n$]))) $\yluego$ \\
    ($n$ $<$ 255 $\impluego$ NodoHijoTerminalTieneSignificado($e$, $n$ $+$ 1))  
  }
  
  ~
  
  \tadOperacion{ContarSignificados}{estr\_nodo}{nat}{}
  \tadAxioma{ContarSignificados($e$)}{(\TADIF e.significado $\igobs$ NULL THEN 0 ELSE 1 FI) $+$ ContarSignificadosDeLosHijos($e$, 0)}

  ~

  \tadOperacion{ContarSignificadosDeLosHijos}{estr\_nodo,nat}{nat}{}
  \tadAxioma{ContarSignificadosDeLosHijos($e$, $n$)}{
    (\TADIF $e$.hijos[$n$] $\igobs$ NULL
     THEN 0 \phantom{xxxxxxxx}
     ELSE ContarSignificados(*($e$.hijos[$n$]))
     FI) $+$ \\
    (\TADIF $n$ $<$ 255
     THEN ContarSignificadosDeLosHijos($e$, $n$ $+$ 1) \phantom{xxxxxxxx}
     ELSE 0
     FI)
  }    
  
  ~

  \textbf{Función de abstracción:}
  
  \begin{enumerate}
    \item El diccionario tiene la misma cantidad de claves que la estructura.
    \item Para cada clave del diccionario:
    \begin{enumerate}
      \item La clave está definida en la estructura.
      \item El significado de la clave en el diccionario es el mismo que en la estructura.
    \end{enumerate}
  \end{enumerate}

  \Abs[estr\_dicctrie]{dicc(string, $\alpha$)}[e]{d}{
    \#(claves($d$)) $\igobs$ $e$.\#Claves $\yluego$ \hfill 1. \\
    ($\forall c$: string)(def?($c$, $d$) $\impluego$ ( \hfill 2. \\
      \margen $¬$(ObtenerDeLaEstructura($c$, $e$.raíz) $\igobs$ NULL) $\yluego$ \hfill 2. a) \\
      \margen obtener($c$, $d$) $\igobs$ ObtenerDeLaEstructura($c$, $e$.raíz) \hfill 2. b) \\
    ))
  }

  ~
  
  \tadOperacion{ObtenerDeLaEstructura}{string,estr\_nodo}{bool}{}
  \tadAxioma{ObtenerDeLaEstructura($c$, $n$)}{\TADIF vacía?($c$)
                                              THEN $n$.significado
                                              ELSE {\TADIF $n$.hijos[Ord(prim($c$))] $\igobs$ NULL
                                                    THEN NULL
                                                    ELSE ObtenerDeLaEstructura(fin($c$), $n$.hijos[Ord(prim($c$))])
                                                    FI}
                                              FI}
\end{Representacion}

~

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearDiccionario}{}{estr\_dicctrie}{$\Theta(1)$}{
    $\Theta(1) + \Theta(1) =$ \\
    $2 * \Theta(1) =$ \\
    $\Theta(1)$.   
  }
    \STATE \CrearTupla{$res$}\CampoTupla{raíz}{\NombreFuncion{iNuevoNodo}()}, \CompTheta{1}
    \STATE \MargenTupla      \CampoTupla{\#Claves}{$0$}\FinTupla \CompTheta{1}
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iNuevoNodo}{}{estr\_nodo}{$\Theta(1)$}{
    $\Theta(1) + \Theta(256) + 256 * \Theta(1) =$ \\
    $\Theta(1) + 256 * \Theta(1) + 256 * \Theta(1) =$ \\    
    $513 * \Theta(1) =$ \\
    $\Theta(1)$.
  }
    \STATE \CrearTupla{$res$}\CampoTupla{significado}{NULL}, \CompTheta{1}
    \STATE \MargenTupla      \CampoTupla{hijos}{\NombreFuncion{CrearArreglo}()}\FinTupla \CompTheta{256}
    \FOR{var $i$: \TipoVariable{nat} $\leftarrow$ $0$ to $255$}
      \STATE $res$.hijos[$i$] $\leftarrow$ NULL \CompTheta{1}
    \ENDFOR 
  \end{Algoritmo}

  ~
   
  \begin{Algoritmo}{iDefinir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{estr\_dicctrie}}{}{$\Theta(|c| + copy(s))$}{
    $\Theta(1) + |c| * (\Theta(1) + \Theta(1) + \Theta(1)) + \Theta(copy(s)) + \Theta(1) =$ \\
    $\Theta(1) + |c| * 3 * \Theta(1) + \Theta(copy(s)) + \Theta(1) =$ \\ 
    $2 * \Theta(1) + |c| * 3 * \Theta(1) + \Theta(copy(s)) =$ \\     
    $|c| * 3 * \Theta(1) + \Theta(copy(s)) =$ \\
    $3 * \Theta(|c|) + \Theta(copy(s)) =$ \\
    $\Theta(|c|) + \Theta(copy(s)) =$ \\
    $\Theta(|c| + copy(s))$.
  }
    \STATE var $actual$: \TipoVariable{puntero(estr\_nodo)} $\leftarrow$ \&($d$.raíz) \CompTheta{1}
    \FOR{var $i$: \TipoVariable{nat} $\leftarrow$ $0$ to \NombreFuncion{Longitud}($c$)}
      \IF{$actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] $\igobs$ NULL}
        \STATE $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] $\leftarrow$ \&(\NombreFuncion{iNuevoNodo}()) \CompTheta{1}
      \ENDIF
        \STATE $actual$ $\leftarrow$ $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] \CompTheta{1}
    \ENDFOR
    \STATE $actual$\DRef significado $\leftarrow$ \&(Copiar($s$)) \CompTheta{copy($s$)}
    \STATE $d$.\#Claves $\leftarrow$ $d$.\#Claves $+$ $1$ \CompTheta{1}
  \end{Algoritmo}
  
  ~

  \begin{Algoritmo}{iObtener}{\In{c}{string}, \In{d}{estr\_dicctrie}}{$\Theta(|c|)$}{$\Theta(|c|)$}{
    $\Theta(1) + |c| * \Theta(1) + \Theta(1) =$ \\
    $2 * \Theta(1) + |c| * \Theta(1) =$ \\
    $|c| * \Theta(1) =$ \\
    $\Theta(|c|)$.
  }
    \STATE var $actual$: \TipoVariable{puntero(estr\_nodo)} $\leftarrow$ \&($d$.raíz) \CompTheta{1} 
    \FOR{var $i$: \TipoVariable{nat} $\leftarrow$ $0$ to \NombreFuncion{Longitud}($c$)}
      \STATE $actual$ $\leftarrow$ $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] \CompTheta{1}
    \ENDFOR   
    \STATE $res$ $\leftarrow$ *($actual$\DRef $significado$) \CompTheta{1}
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{i\#Claves}{\In{d}{estr\_dicctrie}}{nat}{$\Theta(1)$}{}
    \STATE $res$ $\leftarrow$ $d$.\#Claves \CompTheta{1}
  \end{Algoritmo}

\end{Algoritmos}

\end{document}