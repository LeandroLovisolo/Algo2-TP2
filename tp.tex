\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{enumitem}
\usepackage{algorithmic}
\usepackage{scrextend}


\setenumerate{noitemsep}


\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[2]{\emph{#1}: \TipoVariable{#2}}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros nuestros                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%InterfazFuncion(nombre, argumentos, valor retorno)
\newcommandx{\InterfazAlgoritmo}[3]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}%
}

%Algoritmo(nombre, argumentos, valor retorno) { cuerpo }
\newenvironmentx{Algoritmo}[3]{%
  \InterfazAlgoritmo{#1}{#2}{#3}
  \begin{addmargin}[2em]{0em}
    \algsetup{indent=2em}
    \begin{algorithmic}
}
{
    \end{algorithmic}
  \end{addmargin}
}

%CrearTupla(variable en la que se va a guardar) { cuerpo }
\newlength{\lenVariable}
\newenvironmentx{CrearTupla}[1]{%
    \settowidth{\lenVariable}{#1 $\leftarrow$ $\langle$}%
    \addtolength{\lenVariable}{\parindent}%
    #1 $\leftarrow$ $\langle$%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
}{%
    $\rangle$%
    \end{minipage}%
}

%CampoTupla(nombre del campo, valor)
\newcommandx{\CampoTupla}[2]{\TipoVariable{#1}: #2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Árbol de Categorías                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo ÁrbolCategorías}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{ÁrbolCategorías}, \tadNombre{Iterador Unidireccional(Categoría)}.

  \textbf{géneros}: \TipoVariable{acat}, \TipoVariable{itcat}.

  \Titulo{Operaciones básicas de árbol de categorías}
  
  \InterfazFuncion{CrearÁrbol}{\In{raiz}{categoria}}{acat}
  [$¬$vacía?($raiz$)]
  {$res$ $\igobs$ nuevo($raiz$)}
  [$\Theta(|raiz|)$]
  [crea un árbol nuevo cuya categoría raíz es $raiz$.]

  \InterfazFuncion{NombreCategoríaRaíz}{\In{ac}{acat}}{categoria}
  {$res$ $\igobs$ raíz($ac$)}
  [$\Theta(1)$]
  [devuelve el nombre de la categoría raíz de $ac$.]

  \InterfazFuncion{AgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{acat}}{}
  [$ac$ $\igobs$ $ac_{0}$ $\land$ está?($padre$, $ac$) $\land$ $¬$vacía?($hija$) $\land$ $¬$está?($hija$, $ac$)]
  {$ac$ $\igobs$ agregar($ac_{0}$, $padre$, $hija$)}
  [$\Theta(|padre| + |hija|)$]
  [agrega la categoría $hija$ como hija de la categoría $padre$.]
   
  \InterfazFuncion{IdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{acat}}{nat}
  [está?($c$, $ac$)]
  {$res$ $\igobs$ id($ac$, $c$)}
  [$\Theta(|c|)$]
  [devuelve el $id$ de la categoría $c$.]

  \InterfazFuncion{\#Categorías}{\In{ac}{acat}}{nat}
  {$res$ $\igobs$ \#(categorias($ac$))}
  [$\Theta(1)$]
  [devuelve la cantidad de categorías en $ac$.]
  
  \Titulo{Operaciones del iterador de categorías}

  \InterfazFuncion{CrearIter}{\In{padre}{categoria}, \In{ac}{acat}}{itcat}
  [está?($padre$, $ac$)]
  {$res$ $\igobs$ CrearItUni(tuplasHijos($padre$, $ac$)) $\land$ alias(iteraLosHijos($res$, $padre$, $ac$))}
  [$\Theta(|padre|)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría $padre$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría $padre$.]

  \InterfazFuncion{CrearIterRaíz}{\In{ac}{acat}}{itcat}
  {$res$ $\igobs$ CrearItUni(tuplasHijos(raíz($ac$), $ac$)) $\land$ alias(iteraLosHijos($res$, raíz($ac$), $ac$))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría raíz de $ac$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría raíz.]

  \InterfazFuncion{CrearIterDadoOtroIter}{\In{it}{itcat}, \In{ac}{acat}}{itcat}
  [HayMás?($it$)]
  {$res$ $\igobs$ CrearItUni(tuplasHijos($\Pi_1$(Actual($it$)), $ac$)) $\land$ alias(iteraLosHijos($res$, $\Pi_1$(Actual($it$)), $ac$))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría actual del iterador $it$.]
  [Siguientes($res$) podrá cambiar si se agregan nuevas categorías hijas directas a la categoría actual del iterador $it$.]

  \InterfazFuncion{HayMás?}{\In{it}{itcat}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{CategoríaActual}{\In{it}{itcat}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_1$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve el elemento actual del iterador.]

  \InterfazFuncion{IdCategoríaActual}{\In{it}{itcat}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ $\Pi_2$(Actual($it$))}
  [$\Theta(1)$]
  [devuelve el id del elemento actual del iterador.]

  \InterfazFuncion{Avanzar}{\Inout{it}{itcat}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it_{0}$)]
  {$it$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  {
    \offinterlineskip
    \begin{tad}{\tadNombre{Árbol Extendido}}
      \tadExtiende{\tadNombre{ÁrbolCategorías}}

      \tadTitulo{otras operaciones (no exportadas)}{}

      \tadAlinearFunciones{categoríasATuplas}{conj(categoría)/cc,acat/ac}
      \tadOperacion{tuplasHijos}{categoría/c,acat/ac}{secu(tupla(categoría{, }nat))}{$c$ $\in$ categorías($ac$)}
      \tadOperacion{categoríasATuplas}{conj(categoría)/cc,acat/ac}{secu(tupla(categoría{, }nat))}{$cc$ $\subseteq$ categorías($ac$)}
      \tadAlinearFunciones{categoríasATuplas}{secu(tupla(categoría{, }nat)), secu(tupla(categoría{, }nat))}
      \tadOperacion{iteraLosHijos}{itUni(tupla(categoría{, }nat)),categoría,acat}{bool}{}
      \tadOperacion{terminanIgual}{secu(tupla(categoría{, }nat)), secu(tupla(categoría{, }nat))}{bool}{}  

      \tadAxiomas[\paratodo{categoría}{c}, \paratodo{acat}{ac}, \paratodo{conj(categoría)}{cc}, \paratodo{secu(categoría)}{sc},\\
                  \paratodo{secu(tupla(categoría{, }nat))}{st, st'}, \paratodo{itUni(tupla(categoría{, }nat))}{it}]  
  
      \tadAlinearAxiomas{aliasingHijos($it$, $c$, $ac$)}
      \tadAxioma{tuplasHijos($c$, $ac$)}{catsATuplas(hijos($ac$, $c$), $ac$)}      
      \tadAxioma{catsATuplas($cc$, $ac$)}{\TADIF $\emptyset$?($cc$)
                                          THEN \secuencia{}
                                          ELSE \secuencia{$\langle$dameUno($cc$){, }id($ac${, }dameUno($cc$))$\rangle$}
                                                         [categoríasATuplas(sinUno($cc$), $ac$)]
                                          FI}
      \tadAxioma{iteraLosHijos($it$, $c$, $ac$)}{terminanIgual(Siguientes($it$), tuplasHijos($c$, $ac$))}
      \tadAxioma{terminanIgual($st$, $st'$)}{\TADIF vacía?($st$) $\lor$ vacía($st'$)
                                             THEN \textbf{true}
                                             ELSE ult($st$) $\igobs$ ult($st'$) $\land$ terminanIgual(com($st$), com($st'$))
                                             FI}       
    \end{tad}
  }
  
\end{Interfaz}

~

\begin{Representacion}

  \Titulo{Representación de árbol de categorías}

  \begin{Estructura}{acat}[estr\_acat]
    \begin{Tupla}[estr\_acat]
      \tupItem{raíz}{estr\_cat},
      \tupItem{categorías}{dicctrie(estr\_cat)}%
    \end{Tupla}

    \begin{Tupla}[estr\_cat]
      \tupItem{id}{nat},
      \tupItem{nombre}{categoria},
      \tupItem{padre}{puntero(estr\_cat)},
      \\
      \tupItem{hijos}{conj(puntero(estr\_cat))}%
    \end{Tupla}    
  \end{Estructura}

  PENDIENTE: Actualizar y abreviar Rep.
  
  ~

  Invariante de representación:

  \begin{enumerate}
    \item raíz no puede ser nulo.
    \item raíz tiene que estar en el diccionario de categorías.
    \item raíz tiene que tener id 1.
    \item para todas las categorías en el diccionario:
    \begin{enumerate}
      \item la categoría no puede ser nula.
      \item el nombre de la categoría deber ser igual a su clave en el diccionario.
      \item el id de la categoría debe estar en rango.      
      \item dos categorías no pueden tener el mismo id.      
      \item los hijos de la categoría tienen que estar en el diccionario de categorías.
      \item el padre es nulo si y sólo si la categoría es la raíz.
      \item si el padre no es nulo, tiene que estar en el diccionario de categorías.
      \item si el padre no es nulo, la categoría está entre los hijos del padre.
      \item si el padre no es nulo, el id de la categoría debe ser superior al del padre.
    \end{enumerate}
  \end{enumerate}

  \Rep[estr\_acat][e]{ \\
      (1) \hspace*{0mm} $¬$($e$.raíz $\igobs$ NULL) $\yluego$ \\
      (2) \hspace*{0mm} def?($e$.raíz\DRef nombre, $e$.categorías) $\yluego$
                        obtener($e$.raíz\DRef nombre, $e$.categorías) $\igobs$ $e$.raíz $\land$ \\      
      (3) \hspace*{0mm} $e$.raíz\DRef id $\igobs$ 1 $\land$ \\
      (4) \hspace*{0mm} ($\forall c$: categoria)(def?($c$, $e$.categorías) $\impluego$ ( \\
      (4a) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías) $\igobs$ NULL) $\yluego$ \\
      (4b) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef nombre $\igobs$ $c$ $\yluego$ \\
      (4c) \hspace*{5mm} 1 $\leq$ obtener($c$, $e$.categorías)\DRef id $\land$
                        obtener($c$, $e$.categorías)\DRef id $\leq$ \#(claves($e$.categorías)) $\land$ \\
      (4d) \hspace*{5mm} ($\forall c'$: categoría)(obtener($c$, $e$.categorías)\DRef id $\igobs$
                                                  obtener($c'$, $e$.categorías)\DRef id $\ssi$
                                                  $c$ $\igobs$ $c'$) $\land$ \\
      (4e) \hspace*{5mm} ($\forall h$: puntero(datoscat))($h$ $\in$ obtener($c$, $e$.categorías)\DRef hijos $\impluego$ \\
          \hspace*{20mm} def?($h$\DRef nombre, $e$.categorías)) $\yluego$ \\
      (4f) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL $\ssi$ $c$ $\igobs$ $e$.raíz\DRef nombre $\yluego$ \\      
      (4g) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} def?(obtener($c$, $e$.categorías)\DRef padre\DRef nombre, $e$.categorías) $\yluego$ \\
      (4h) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías) $\in$ obtener($c$, $e$.categorías)\DRef padre\DRef hijos) $\land$ \\ 
      (4i) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías)\DRef padre\DRef id < \ obtener($c$, $e$.categorías)\DRef id))
  }

  \mbox{}

  \Abs[estr\_acat]{acat}[e]{ac}
    {categorias($ac$) $\igobs$ claves($e$.categorías) $\yluego$ \\
    raíz($ac$) $\igobs$ $e$.raíz\DRef nombre $\land$ \\
    ($\forall c$: categoria)($c$ $\in$ claves($e$.categorías) $\impluego$ ( \\
    \hspace*{5mm} padre($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef padre\DRef nombre $\land$ \\
    \hspace*{5mm} id($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef id))
  }

  ~

  \Titulo{Representación del iterador de categorías}  
  
  \begin{Estructura}{itcat}[itConj(puntero(estr\_cat))]
  \end{Estructura}
  
  PENDIENTE: Rep y Abs.

  ~    

\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearÁrbol}{\In{raiz}{categoria}}{estr\_acat}
  	\STATE var $estr\_raiz$: \TipoVariable{estr\_cat}
	\STATE \begin{CrearTupla}{$estr\_raiz$}
	         \CampoTupla{id}{1},
             \CampoTupla{nombre}{$raiz$},
             \CampoTupla{padre}{NULL},
             \CampoTupla{hijos}{\NombreFuncion{Vacío}()}%
           \end{CrearTupla}
	\STATE var $categorias$: \TipoVariable{dicctrie(estr\_cat)}
    \STATE $categorias$ $\leftarrow$ \NombreFuncion{CrearDiccionario}()
    \STATE \NombreFuncion{Definir}($raiz$, $estr\_raiz$, $categorias$)
	\STATE \begin{CrearTupla}{$res$}
	         \CampoTupla{raíz}{$estr\_raiz$},	
             \CampoTupla{categorías}{$categorias$}%
           \end{CrearTupla}
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iNombreCategoríaRaíz}{\In{ac}{estr\_acat}}{categoria}
	\STATE $res$ $\leftarrow$ $ac$.raíz.nombre
  \end{Algoritmo}  

  ~
  
  \begin{Algoritmo}{iAgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{estr\_acat}}{}
  	\STATE var $estr\_padre$: \TipoVariable{estr\_cat}  
  	\STATE $estr\_padre$ $\leftarrow$ \NombreFuncion{Obtener}($padre$, $ac$.categorías)
  	\STATE var $estr\_hija$: \TipoVariable{estr\_cat}
	\STATE \begin{CrearTupla}{$estr\_hija$}
	         \CampoTupla{id}{\NombreFuncion{\#Claves}($ac$.categorías) + 1},
	         \CampoTupla{nombre}{$hija$},
	         \CampoTupla{padre}{\&($estr\_padre$)},
	         \CampoTupla{hijos}{\NombreFuncion{Vacío}()$\rangle$}%
	       \end{CrearTupla}
    \STATE \NombreFuncion{AgregarRápido}($estr\_padre$.hijos, \&($estr\_hija$))
    \STATE \NombreFuncion{Definir}($hija$, $estr\_hija$, $ac$)
  \end{Algoritmo}

  ~   
    
  \begin{Algoritmo}{iIdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{estr\_acat}}{nat}
  	\STATE $res$ $\leftarrow$ \NombreFuncion{Obtener}($c$, $ac$.categorías).id
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{i\#Categorías}{\In{ac}{estr\_acat}}{nat}
  	\STATE $res$ $\leftarrow$ \NombreFuncion{\#Claves}($ac$.categorías)
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearIter}{\In{padre}{categoria}, \In{ac}{acat}}{itConj(puntero(estr\_cat))}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Obtener}($padre$, $ac$.categorías).hijos)
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearIterRaíz}{\In{ac}{acat}}{itConj(puntero(estr\_cat))}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}($ac$.raíz.hijos)
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iCrearIterDadoOtroIter}{\In{it}{itConj(puntero(estr\_cat))}}{itConj(puntero(estr\_cat))}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Siguiente}(it)\DRef hijos)
  \end{Algoritmo}  

  ~  
  
  \begin{Algoritmo}{iHayMás?}{\In{it}{itConj(puntero(estr\_cat))}}{bool}
    \STATE $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$)
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCategoríaActual}{\In{it}{itConj(puntero(estr\_cat))}}{categoria}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$)\DRef nombre
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iIdCategoríaActual}{\In{it}{itConj(puntero(estr\_cat))}}{nat}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$)\DRef id
  \end{Algoritmo}  
  
  ~
  
  \begin{Algoritmo}{iAvanzar}{\Inout{it}{itConj(puntero(estr\_cat))}}{}
    \STATE \NombreFuncion{Avanzar}($it$)
  \end{Algoritmo}

\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LinkLinkIt                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Módulo LinkLinkIt}

\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{LinkLinkIt}, \tadNombre{Iterador Unidireccional(Link)}.

  \textbf{géneros}: \TipoVariable{sistema}, \TipoVariable{iterlinks}.

  \Titulo{Operaciones básicas del sistema}
  
  \InterfazFuncion{CrearSistema}{\In{ac}{acat}}{sistema}
  {$res$ $\igobs$ iniciar($ac$)}
  [$\Theta$(\#(categorías($ac$))]
  [crea un sistema cuyo árbol de categorías es $ac$.]

  \InterfazFuncion{AgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $¬$($l$ $\in$ links($s$)) $\land$ está?($c$, categorías($s$)]
  {$s$ $\igobs$ nuevoLink($s_{0}$, $l$, $c$)}
  [$\Theta$(|$l$| + |$c$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [agrega al sistema el link $l$ con categoría $c$.]

  \InterfazFuncion{AccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $l$ $\in$ links($s$) $\land$ $f$ $\geq$ fechaActual($s$)]
  {$s$ $\igobs$ acceso($s_{0}$, $l$, $f$)}
  [$\Theta$(|$l$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [registra un acceso al link $l$ en la fecha $f$.]

  \InterfazFuncion{\#Links}{\In{c}{categoría}, \In{s}{sistema}}{nat}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ cantLinks($s$, $c$)}
  [$\Theta$(|$c$|)]
  [devuelve la cantidad de links bajo la categoría $c$ y todas sus subcategorías.]

  \Titulo{Operaciones de iterador de links}

  \InterfazFuncion{CrearIterLinks}{\In{c}{categoría}, \In{s}{sistema}}{iterlinks}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ $\langle$iter: CrearItUni(linksOrdenadosPorAccesos($s$, $c$)), sis: $s\rangle$ $\land$ alias(iteraLinksCorrectos($res$, $c$))}  
  [$\Theta$(|$c$| + $n^2$), donde $n$ representa long(linksOrdenadosPorAccesos($s$, $c$)).]
  [devuelve un iterador unidireccional de los links de la categoría $c$ y todas sus subcategorías ordenados de mayor a menor cantidad de accesos recientes.]
  [Siguientes($res$.iter) podrá cambiar si se agregan links a la categoría $c$ o alguna subcategoría y/o si se registran accesos a links de dichas categorías.]  
   
  \InterfazFuncion{HayMás?}{\In{it}{iterlinks}}{bool}
  {$res$ $\igobs$ HayMás?($it$.iter)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{LinkActual}{\In{it}{iterlinks}}{link}
  [HayMás?($it$.iter)]
  {$res$ $\igobs$ Actual($it$.iter)}
  [$\Theta(1)$]
  [devuelve el link actual del iterador.]

  \InterfazFuncion{CategoríaLinkActual}{\In{it}{iterlinks}}{categoria}
  [HayMás?($it$.iter)]
  {$res$ $\igobs$ categoríaLink($it$.sis, Actual($it$.iter))}
  [$\Theta(1)$]
  [devuelve la categoría del link actual del iterador.]

  \InterfazFuncion{AccesosRecientesLinkActual}{\In{it}{iterlinks}}{nat}
  [HayMás?($it$.iter)]
  {$res$ $\igobs$ accesosRecientes($it$.sis, categoríaLink($it$.sis, Actual($it$.iter)), Actual($it$.iter))}
  [$\Theta(1)$]
  [devuelve la cantidad de accesos del link actual del iterador durante los días de la intersección
   entre los tres días ``recientes'' del link $l$ y los tres días ``recientes'' del link que tuvo
   último acceso entre los links de la categoría $c$ con la que se creó este iterador, y los links
   de todas sus subcategorías.]

  \InterfazFuncion{Avanzar}{\Inout{it}{iterlinks}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$.iter)]
  {$it$ $\igobs$ $\langle$iter: Avanzar($it_{0}$), sis: $it_{0}$.sis$\rangle$}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]  

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  {
    \offinterlineskip
    \begin{tad}{\tadNombre{Sistema Extendido}}
      \tadExtiende{\tadNombre{LinkLinkIt}}

      \tadTitulo{otras operaciones (no exportadas)}{}

      \tadAlinearFunciones{iteraLinksCorrectos}{tupla(itUni(link){, }lli),categoría}
      \tadOperacion{iteraLinksCorrectos}{tupla(itUni(link){, }lli),categoría}{bool}{}
      \tadOperacion{terminanIgual}{secu(link),secu(link)}{bool}{}

      \tadAxiomas[\paratodo{categoría}{c}, \paratodo{secu(link)}{ls, ls'}, \paratodo{tupla(itUni(link){, }lli)}{t}]  
  
      \tadAlinearAxiomas{iteraLinksCorrectos($t$, $c$)}
	  \tadAxioma{iteraLinksCorrectos($t$, $c$)}{terminanIgual(Siguientes($\Pi_1$($t$)), linksOrdenadosPorAccesos($\Pi_2$($t$), $c$))}
      \tadAxioma{terminanIgual($ls$, $ls'$)}{\TADIF vacía?($ls$) $\lor$ vacía?($ls'$)
                                             THEN \textbf{true}
                                             ELSE ult($ls$) $\igobs$ ult($ls'$) $\land$ terminanIgual(com($ls$), com($ls'$))
                                             FI}
    \end{tad}
  }
  
\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación del sistema}
  
  \begin{Estructura}{sistema}[estr\_sistema]
    \begin{Tupla}[estr\_sistema]
      \tupItem{categorías}{acat},
      \tupItem{links}{dicctrie(estr\_link)},\\
      \tupItem{linksPorCatId}{arreglo\_dimensionable de estr\_linksPorCatId},\\
      \tupItem{fechaActual}{fecha}%
    \end{Tupla}
    
    \begin{Tupla}[estr\_link]
      \tupItem{l}{link},
      \tupItem{cid}{nat},
      \tupItem{últimoAcceso}{fecha},
      \tupItem{as}{arreglo\_estático[3] de fecha}%
    \end{Tupla}
    
    \begin{Tupla}[estr\_linksPorCatId]
      \tupItem{idPadre}{nat},
      \tupItem{links}{lista(puntero(estr\_link))},\\
      \tupItem{últimoAcceso}{fecha},
      \tupItem{ordenado?}{bool}%            
    \end{Tupla}    
  \end{Estructura}
  
  \Titulo{Representación de iterador de links}  
  
  \begin{Estructura}{iterlinks}[estr\_iter]
    \begin{Tupla}[estr\_iter]
      \tupItem{s}{estr\_sistema},
      \tupItem{cid}{nat},
      \tupItem{it}{itLista(puntero(estr\_link))}%
    \end{Tupla}
  \end{Estructura}
  
\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearSistema}{\In{ac}{estr\_acat}}{estr\_sistema}
    \STATE \begin{CrearTupla}{$res$}
             \CampoTupla{categorías}{$ac$},
             \CampoTupla{links}{\NombreFuncion{CrearDiccionario}()},\\
             \CampoTupla{linksPorCatId}{\NombreFuncion{CrearArreglo}(\NombreFuncion{\#Categorías}($ac$))},
             \CampoTupla{fechaActual}{0}%
           \end{CrearTupla} 
    \STATE \begin{CrearTupla}{$res$.linksPorCatId[0]}
             \CampoTupla{cat}{\NombreFuncion{NombreCategoríaRaíz}($ac$)},
             \CampoTupla{idPadre}{0},
             \CampoTupla{links}{\NombreFuncion{Vacía}()},\\
             \CampoTupla{últimoAcceso}{0},
             \CampoTupla{ordenado?}{\textbf{false}}%
           \end{CrearTupla}
    \STATE \NombreFuncion{iAgregarALinksPorCatId(CrearIterRaíz($ac$), 1, $res$)}   
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAgregarALinksPorCatId}{\Inout{it}{itcat}, \In{idPadre}{nat}, \Inout{s}{estr\_sistema}}{}
    \WHILE{\NombreFuncion{HayMás?}($it$)}
      \STATE \begin{CrearTupla}{$s$.linksPorCatId[\NombreFuncion{IdCategoríaActual}($it$) - 1]}
               \CampoTupla{cat}{\NombreFuncion{CategoríaActual}($it$)},
               \CampoTupla{idPadre}{$idPadre$},\\
               \CampoTupla{links}{\NombreFuncion{Vacía}()},
               \CampoTupla{últimoAcceso}{0},
               \CampoTupla{ordenado?}{\textbf{false}}%
             \end{CrearTupla}
      \STATE \NombreFuncion{iAgregarALinksPorCatId}(\NombreFuncion{CrearIterDadoOtroIter}($it$), \NombreFuncion{IdCategoríaActual}($it$), $s$)
      \STATE \NombreFuncion{Avanzar}($it$)
    \ENDWHILE
  \end{Algoritmo}
    
  ~  
  
  \begin{Algoritmo}{iAgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{estr\_sistema}}{}
  	\STATE var $estr\_l$: \TipoVariable{estr\_link}
  	\STATE \begin{CrearTupla}{$estr\_l$}
             \CampoTupla{l}{$l$},
             \CampoTupla{cid}{\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías)},\\
             \CampoTupla{últimoAcceso}{$s$.fechaActual},
             \CampoTupla{as}{\NombreFuncion{iCrearArregloDe3Nats}(0, 0, 0)}%
  	       \end{CrearTupla}
 	\STATE \NombreFuncion{Definir}($l$, $estr\_l$, $s$.links)
 	\STATE
    \STATE var $cid$: \TipoVariable{nat}
    \STATE $cid$ $\leftarrow$ $estr\_l$.cid
 	\STATE
 	\WHILE{$¬$($cid$ $\igobs$ 0)}
      \STATE \NombreFuncion{AgregarAtrás}($s$.linksPorCatId[$cid$ - 1].links, \&($estr\_l$))
 	  \STATE $s$.linksPorCatId[$cid$ - 1].últimoAcceso $\leftarrow$ $s$.fechaActual
 	  \STATE $s$.linksPorCatId[$cid$ - 1].ordenado? $\leftarrow$ \textbf{false}
 	  \STATE $cid$ $\leftarrow$ $s$.linksPorCatId[$cid$ - 1].idPadre
 	\ENDWHILE
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{estr\_sistema}}{}
    \STATE var $estr\_l$: \TipoVariable{estr\_link}
    \STATE $estr\_l$ $\leftarrow$ \NombreFuncion{Obtener}($l$, $s$.links)
	\IF{$f$ $\igobs$ $estr\_l$.últimoAcceso}
	  \STATE $estr\_l$.as[0] $\leftarrow$ $estr\_l$.as[0] + 1
	\ELSIF{$f$ $\igobs$ $estr\_l$.últimoAcceso + 1}
	  \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, $estr\_l$.as[0], $estr\_l$.as[1])
	\ELSIF{$f$ $\igobs$ $estr\_l$.últimoAcceso + 2}
	  \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, 0, $estr\_l$.as[0])
	\ELSE
	  \STATE $estr\_l$.as $\leftarrow$ \NombreFuncion{iCrearArregloDe3Nats}(1, 0, 0)
	\ENDIF
 	\STATE
 	\STATE $s$.fechaActual $\leftarrow$ $f$	
 	\STATE
    \STATE var $cid$: \TipoVariable{nat}
    \STATE $cid$ $\leftarrow$ $estr\_l$.cid
 	\STATE
 	\WHILE{$¬$($cid$ $\igobs$ 0)}
 	  \STATE $s$.linksPorCatId[$cid$ - 1].últimoAcceso $\leftarrow$ $s$.fechaActual
 	  \STATE $s$.linksPorCatId[$cid$ - 1].ordenado? $\leftarrow$ \textbf{false}
 	  \STATE $idPadre$ $\leftarrow$ $s$.linksPorCatId[$cid$ - 1].idPadre
 	\ENDWHILE  	 	
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCrearArregloDe3Nats}{\In{a}{nat}, \In{b}{nat}, \In{c}{nat}}{arreglo\_estático[3] de nat}
    \STATE $\res$ $\leftarrow$ \NombreFuncion{CrearArreglo}()
    \STATE $\res$[0] $\leftarrow$ $a$
    \STATE $\res$[1] $\leftarrow$ $b$
    \STATE $\res$[2] $\leftarrow$ $c$
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{i\#Links}{\In{c}{categoría}, \In{s}{estr\_sistema}}{nat}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Longitud}($s$.linksPorCatId[\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías) - 1].links)
  \end{Algoritmo}

  
  ~  
  
  \begin{Algoritmo}{iCrearIterLinks}{\In{c}{categoría}, \In{s}{estr\_sistema}}{estr\_iter}
    \STATE var $estr\_c$: \TipoVariable{estr\_linksPorCatId}
  	\STATE $estr\_c$ $\leftarrow$ $s$.linksPorCatId[\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías) - 1]
  	\IF{$¬$($estr\_c$.ordenado?)}
      \STATE \NombreFuncion{iOrdenarLinks}($estr\_c$)
  	\ENDIF
    \STATE \begin{CrearTupla}{$res$}
	         \CampoTupla{s}{$s$},
             \CampoTupla{cid}{\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías)},
             \CampoTupla{it}{\NombreFuncion{CrearIt}($estr\_c$.links)}%
           \end{CrearTupla}           
  \end{Algoritmo}  
  
  ~
  
  \begin{Algoritmo}{iOrdenarLinks}{\In{estr\_c}{estr\_linksPorCatId}}{}
    \STATE var $it$: \TipoVariable{itLista(puntero(estr\_link))}
    \STATE $it$ $\leftarrow$ \NombreFuncion{CrearIt}($estr\_c$.links)  	
  	\WHILE{\NombreFuncion{HaySiguiente}($it$)}
      \STATE var $it'$: \TipoVariable{itLista(puntero(estr\_link))}
      \STATE $it'$ $\leftarrow$ \NombreFuncion{Copiar}($it$)
      \STATE var $itMax$: \TipoVariable{itLista(puntero(estr\_link))}      
      \STATE $itMax$ $\leftarrow$ \NombreFuncion{Copiar}($it'$)
      \WHILE{\NombreFuncion{HaySiguiente}($it'$)}
        \IF{\NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Siguiente}($it'$), $estr\_c$) $>$
            \NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Siguiente}($itMax$), $estr\_c$)}
          \STATE $itMax$ $\leftarrow$ \NombreFuncion{Copiar}($it'$)
  	  	\ENDIF
		\STATE \NombreFuncion{Avanzar($it'$)}
	  \ENDWHILE
	  \STATE \NombreFuncion{iIntercamabiar}($it$, $itMax$)  	
  	  \STATE \NombreFuncion{Avanzar($it$)}
  	\ENDWHILE
  	\STATE $estr\_c$.ordenado? $\leftarrow$ \textbf{true}  
  \end{Algoritmo}  
  
  ~  

  \begin{Algoritmo}{iAccesosRecientes}{\In{estr\_l}{estr\_link}, \In{estr\_c}{estr\_linksPorCatId}}{nat}
    \IF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso}
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0] + $estr\_l$.as[1] + $estr\_l$.as[2]
    \ELSIF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso + 1}
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0] + $estr\_l$.as[1]
    \ELSIF{$estr\_c$.últimoAcceso $\igobs$ $estr\_l$.últimoAcceso + 2}          
      \STATE $res$ $\leftarrow$ $estr\_l$.as[0]
    \ELSE
      \STATE $res$ $\leftarrow$ 0
    \ENDIF
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iIntercambiar}{\Inout{it}{itLista(puntero(estr\_link))}, \Inout{it'}{itLista(puntero(estr\_link))}}{}
    \STATE var $ptr$: \TipoVariable{puntero(estr\_link)}
    \STATE $ptr$ $\leftarrow$ \NombreFuncion{Siguiente}($it'$)
    \STATE \NombreFuncion{EliminarSiguiente}($it'$)
    \STATE \NombreFuncion{AgregarComoSiguiente}($it'$, \NombreFuncion{Siguiente}($it$))
    \STATE \NombreFuncion{EliminarSiguiente}($it$)
    \STATE \NombreFuncion{AgregarComoSiguiente}($it$, $ptr$)
  \end{Algoritmo}
      
  
  ~  
  
  \begin{Algoritmo}{iHayMás?}{\In{it}{estr\_iter}}{bool}
    $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$.it)
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iLinkActual}{\In{it}{estr\_iter}}{link}
    $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$.it)\DRef l
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iCategoríaLinkActual}{\In{it}{estr\_iter}}{categoria}
    $res$ $\leftarrow$ $it$.s.linksPorCatId[\NombreFuncion{Siguiente}($it$.it)\DRef cid - 1].cat
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccesosRecientesLinkActual}{\In{it}{estr\_iter}}{nat}
    \STATE $res$ $\leftarrow$ \NombreFuncion{iAccesosRecientes}(*\NombreFuncion{Actual}($it$.iter), $it$.s.linksPorCatId[$it$.cid - 1])
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAvanzar}{\Inout{it}{estr\_iter}}{}
    \NombreFuncion{Avanzar}($it$.it)
  \end{Algoritmo}
  
\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diccionario Trie                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo Diccionario Trie($\alpha$)}

\begin{Interfaz}
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Diccionario(String, $\alpha$)}.

  \textbf{géneros}: \TipoVariable{dicctrie$(\alpha)$}.

  \Titulo{Operaciones básicas de diccionario trie}
  
  \InterfazFuncion{CrearDiccionario}{}{dicctrie$(\alpha)$}
  {$res$ $\igobs$ vacío()}
  [$\Theta(1)$]
  [crea un nuevo diccionario vacío.]

  \InterfazFuncion{Definir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{dicctrie$(\alpha)$}}{}
  [$d$ $\igobs$ $d_{0}$]
  {$d$ $\igobs$ definir($d_{0}$, $c$, $s$)}
  [$\Theta(|c| + copy(s))$]
  [define la clave $c$ con el significado $s$ en el diccionario.]
  
  \InterfazFuncion{Obtener}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{$\alpha$}
  [def?($c$, $d$)]
  {$res$ $\igobs$ obtener($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve el significado de la clave $c$ en $d$.]  
   
  \InterfazFuncion{\#Claves}{\In{d}{dicctrie$(\alpha)$}}{nat}
  {$res$ $\igobs$ \#(claves($d$))}
  [$\Theta(1)$]
  [devuelve la cantidad de claves del diccionario.]    

\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación de diccionario trie}
  
  \begin{Estructura}{dicctrie$(\alpha)$}[estr\_dicctrie]
    \begin{Tupla}[estr\_dicctrie]
      \tupItem{raíz}{nodo},
      \tupItem{\#Claves}{nat}%
    \end{Tupla}
   
    \begin{Tupla}[nodo]
      \tupItem{significado}{puntero$(\alpha)$},    
      \tupItem{hijos}{arreglo\_estático[256] de puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}
  
    \Abs[estr\_dicctrie]{dicc(string, $\alpha$)}[e]{d}
    {($\forall c$: string) estáEnTrie?($c$, $e$.nodos) $\igobs$ def?($c$, $d$) $\land$ \\
    estáEnTrie?($c$,$e$.nodos) $\impluego$ (obtenerDelTrie($c$, $e$) $\igobs$ obtener($c$, $e$))

estáEnTrie?: ab(puntero(nodo)) x nodo $\longrightarrow$ bool \\
\hspace*{5mm}estáEnTrie?(s, n) = auxEstáEnTrie(0,s,n)
\\
\hspace*{5mm}auxEstáEnTrie?: nat x ab(puntero(nodo)) x nodo $\longrightarrow$ bool \\
\hspace*{5mm}auxEstáEnTrie?(i, s, n) = if (tam(s)-1 = i) then \\
\hspace*{50mm}(if $\neg$(n.significado = NULL) then \\
\hspace*{60mm}True\\
\hspace*{50mm}else\\
\hspace*{60mm}False fi) \\
\hspace*{40mm}else (if (n.nodos[ord(s[i])] = NULL) then \\
\hspace*{50mm}False \\
\hspace*{50mm}else \\
\hspace*{60mm}auxEstáEnTrie?(i+1,  s, (*n.nodos[ord(s[i])]))
\\
\hspace*{5mm}obtenerDelTrie: ab(puntero(nodo)) s x nodo n $\longrightarrow$ $\alpha$\hspace*{65mm}\{estáEnTrie?(s,n)\} 

obtenerDelTrie(s,n) = auxObtenerDelTrie(0,s,n)

auxObtenerDelTrie: nat x string x nodo $\longrightarrow$ $\alpha$

auxObtenerDelTrie(i, s, n) = if (tam(s)-1 = i) then n.significado else ObtenerDelTrie(i+1,  s, (*n.nodos[ord(s[i])]))

}
\end{Representacion}

~

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearDiccionario}{}{estr\_dicctrie}
    \STATE \begin{CrearTupla}{$res$}
             \CampoTupla{raíz}{\NombreFuncion{iNuevoNodo}()},
             \CampoTupla{\#Claves}{$0$}%
           \end{CrearTupla}
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iNuevoNodo}{}{nodo}
    \STATE \begin{CrearTupla}{$res$}
             \CampoTupla{significado}{NULL},
             \CampoTupla{hijos}{\NombreFuncion{CrearArreglo}()}%
           \end{CrearTupla}
    \STATE var $i$: \TipoVariable{nat}
    \FOR{$i$ $\leftarrow$ $0$ to $255$}
      \STATE $res$.hijos[$i$] $\leftarrow$ NULL
    \ENDFOR 
  \end{Algoritmo}

  ~
   
  \begin{Algoritmo}{iDefinir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{estr\_dicctrie}}{}
    \STATE var $actual$: \TipoVariable{puntero(nodo)}
    \STATE $actual$ $\leftarrow$ \&($d$.raíz)
    \STATE var $i$: \TipoVariable{nat}
    \FOR{$i$ $\leftarrow$ $0$ to \NombreFuncion{Longitud}($c$)}
      \IF{$actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] $\igobs$ NULL}
        \STATE $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])] $\leftarrow$ \&(\NombreFuncion{iNuevoNodo}())
      \ENDIF
        \STATE $actual$ $\leftarrow$ $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])]
    \ENDFOR
    \STATE $actual$\DRef significado $\leftarrow$ \&(Copiar($s$))
    \STATE $d$.\#Claves $\leftarrow$ $d$.\#Claves $+$ $1$
  \end{Algoritmo}
  
  ~

  \begin{Algoritmo}{iObtener}{\In{c}{string}, \In{d}{estr\_dicctrie}}{$\alpha$}
    \STATE var $actual$: \TipoVariable{puntero(nodo)}
    \STATE $actual$ $\leftarrow$ \&($d$.raíz)
    \STATE var $i$: \TipoVariable{nat}
    \FOR{$i$ $\leftarrow$ $0$ to \NombreFuncion{Longitud}($c$)}
      \STATE $actual$ $\leftarrow$ $actual$\DRef hijos[\NombreFuncion{Ord}($c$[$i$])]
    \ENDFOR   
    \STATE $res$ $\leftarrow$ *($actual$\DRef $significado$)
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{i\#Claves}{\In{d}{estr\_dicctrie}}{nat}
    $res$ $\leftarrow$ $d$.\#Claves
  \end{Algoritmo}

\end{Algoritmos}

\end{document}