\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{enumitem}
\usepackage{algorithmic}
\usepackage{scrextend}


\setenumerate{noitemsep}


\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros nuestros                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%InterfazFuncion(nombre, argumentos, valor retorno)
\newcommandx{\InterfazAlgoritmo}[3]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}%
}

%Algoritmo(nombre, argumentos, valor retorno) { cuerpo }%
\newenvironmentx{Algoritmo}[3]{%
  \InterfazAlgoritmo{#1}{#2}{#3}
  \begin{addmargin}[2em]{0em}
    \algsetup{indent=2em}
    \begin{algorithmic}
}
{
    \end{algorithmic}
  \end{addmargin}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Árbol de Categorías                                                       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo ÁrbolCategorías}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{ÁrbolCategorías}, \tadNombre{Iterador Unidireccional(Categoría)}.

  \textbf{géneros}: \TipoVariable{acat}, \TipoVariable{itercathijos}, \TipoVariable{itercatancestros}.

  \Titulo{Operaciones básicas de árbol de categorías}
  
  \InterfazFuncion{CrearÁrbol}{\In{raiz}{categoria}}{acat}
  [$¬$vacía?($raiz$)]
  {$res$ $\igobs$ nuevo($raiz$)}
  [$\Theta(|raiz|)$]
  [crea un árbol nuevo cuya categoría raíz es $raiz$.]

  \InterfazFuncion{NombreCategoríaRaíz}{\In{ac}{acat}}{categoria}
  {$res$ $\igobs$ raíz($ac$)}
  [$\Theta(1)$]
  [devuelve el nombre de la categoría raíz de $ac$.]

  \InterfazFuncion{AgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{acat}}{}
  [$ac$ $\igobs$ $ac_{0}$ $\land$ está?($padre$, $ac$) $\land$ $¬$vacía?($hija$) $\land$ $¬$está?($hija$, $ac$)]
  {$ac$ $\igobs$ agregar($ac_{0}$, $padre$, $hija$)}
  [$\Theta(|padre| + |hija|)$]
  [agrega la categoría $hija$ como hija de la categoría $padre$.]
   
  \InterfazFuncion{IdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{acat}}{nat}
  [está?($c$, $ac$)]
  {$res$ $\igobs$ id($ac$, $c$)}
  [$\Theta(|c|)$]
  [devuelve el $id$ de la categoría $c$.]

  \InterfazFuncion{\#Categorías}{\In{ac}{acat}}{nat}
  {$res$ $\igobs$ \#(categorias($ac$))}
  [$\Theta(1)$]
  [devuelve la cantidad de categorías en $ac$.]
  
  \Titulo{Operaciones del iterador de hijos directos}

  \InterfazFuncion{CrearIterHijos}{\In{padre}{categoria}, \In{ac}{acat}}{itercathijos}
  [está?($padre$, $ac$)]
  {esPermutacion?(Siguientes($res$), hijos($ac$, $padre$))}
  [$\Theta(|padre|)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría $padre$.]

  \InterfazFuncion{CrearIterHijosDeLaRaíz}{\In{ac}{acat}}{itercathijos}
  {esPermutacion?(Siguientes($res$), hijos($ac$, raíz($ac$)))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría raíz de $ac$.]

  \InterfazFuncion{CrearIterHijosDadoOtroIter}{\In{it}{itercathijos}}{itercathijos}
  [HayMás?($it$)]
  {esPermutacion?(Siguientes($res$), hijos(Actual($it$)))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de las categorías hijas directas de la categoría actual del iterador $it$.]


  \InterfazFuncion{HayMásHijos?}{\In{it}{itercathijos}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{HijoActual}{\In{it}{itercathijos}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ Actual($it$)}
  [$\Theta(1)$]
  [devuelve el elemento actual del iterador.]

  \InterfazFuncion{IdHijoActual}{\In{it}{itercathijos}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ id(Actual($it$), $ac$)}
  [$\Theta(1)$]
  [devuelve el id del elemento actual del iterador.]

  DUDA: ¿De dónde saco el árbol de categorías $ac$ para especificar la postcondición de IdHijoActual?

  \InterfazFuncion{AvanzarHijo}{\Inout{it}{itercathijos}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$res$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]

  \Titulo{Operaciones del iterador de ancestros}

  \InterfazFuncion{CrearIterAncestros}{\In{it}{itercathijos}}{itercatancestros}
  {esPermutacion?(Siguientes($res$), ancestros($ac$, Actual($it$))}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de la categoría actual de $it$ y sus ancestros.]

  \InterfazFuncion{CrearIterAncestrosDeLaRaíz}{\In{ac}{acat}}{itercatancestros}
  {Actual($res$) $\igobs$ raíz($ac$)}
  [$\Theta(1)$]
  [devuelve un iterador unidireccional de ancestros de la categoría raíz de $ac$.]

  DUDA: ¿Dónde puedo agregar las operaciones ``esPermutacion?'' y ``ancestros''?

  \InterfazFuncion{CopiarIterAncestros}{\In{it}{itercatancestros}}{itercatancestros}
  {$res$ $\igobs$ $it$}
  [$\Theta(1)$]
  [devuelve una copia del iterador de ancestros $it$.]
  
  \InterfazFuncion{HayMásAncestros?}{\In{it}{itercatancestros}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{AncestroActual}{\In{it}{itercatancestros}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ Actual($it$)}
  [$\Theta(1)$]
  [devuelve el elemento actual del iterador.]

  \InterfazFuncion{IdAncestroActual}{\In{it}{itercatancestros}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ id(Actual($it$), $ac$)}
  [$\Theta(1)$]
  [devuelve el id del elemento actual del iterador.]  

  DUDA: ¿De dónde saco el árbol de categorías $ac$ para especificar la postcondición de IdAncestroActual?

  \InterfazFuncion{AvanzarAncestro}{\Inout{it}{itercatancestros}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$res$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]


\end{Interfaz}

~

\begin{Representacion}

  \Titulo{Representación de árbol de categorías}

  \begin{Estructura}{acat}[estr\_acat]
    \begin{Tupla}[estr\_acat]
      \tupItem{raíz}{estr\_cat}%
      \tupItem{categorías}{dicctrie(estr\_cat)}%
    \end{Tupla}
    \begin{Tupla}[estr\_cat]
      \tupItem{id}{nat}
      \tupItem{nombre}{categoria}
      \tupItem{padre}{puntero(estr\_cat)}
      \tupItem{hijos}{conj(estr\_cat)}
    \end{Tupla}    
  \end{Estructura}

  PENDIENTE: Actualizar y abreviar Rep.
  
  ~

  Invariante de representación:

  \begin{enumerate}
    \item raíz no puede ser nulo.
    \item raíz tiene que estar en el diccionario de categorías.
    \item raíz tiene que tener id 1.
    \item para todas las categorías en el diccionario:
    \begin{enumerate}
      \item la categoría no puede ser nula.
      \item el nombre de la categoría deber ser igual a su clave en el diccionario.
      \item el id de la categoría debe estar en rango.      
      \item dos categorías no pueden tener el mismo id.      
      \item los hijos de la categoría tienen que estar en el diccionario de categorías.
      \item el padre es nulo si y sólo si la categoría es la raíz.
      \item si el padre no es nulo, tiene que estar en el diccionario de categorías.
      \item si el padre no es nulo, la categoría está entre los hijos del padre.
      \item si el padre no es nulo, el id de la categoría debe ser superior al del padre.
    \end{enumerate}
  \end{enumerate}

  \Rep[estr\_acat][e]{ \\
      (1) \hspace*{0mm} $¬$($e$.raíz $\igobs$ NULL) $\yluego$ \\
      (2) \hspace*{0mm} def?($e$.raíz\DRef nombre, $e$.categorías) $\yluego$
                        obtener($e$.raíz\DRef nombre, $e$.categorías) $\igobs$ $e$.raíz $\land$ \\      
      (3) \hspace*{0mm} $e$.raíz\DRef id $\igobs$ 1 $\land$ \\
      (4) \hspace*{0mm} ($\forall c$: categoria)(def?($c$, $e$.categorías) $\impluego$ ( \\
      (4a) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías) $\igobs$ NULL) $\yluego$ \\
      (4b) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef nombre $\igobs$ $c$ $\yluego$ \\
      (4c) \hspace*{5mm} 1 $\leq$ obtener($c$, $e$.categorías)\DRef id $\land$
                        obtener($c$, $e$.categorías)\DRef id $\leq$ \#(claves($e$.categorías)) $\land$ \\
      (4d) \hspace*{5mm} ($\forall c'$: categoría)(obtener($c$, $e$.categorías)\DRef id $\igobs$
                                                  obtener($c'$, $e$.categorías)\DRef id $\ssi$
                                                  $c$ $\igobs$ $c'$) $\land$ \\
      (4e) \hspace*{5mm} ($\forall h$: puntero(datoscat))($h$ $\in$ obtener($c$, $e$.categorías)\DRef hijos $\impluego$ \\
          \hspace*{20mm} def?($h$\DRef nombre, $e$.categorías)) $\yluego$ \\
      (4f) \hspace*{5mm} obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL $\ssi$ $c$ $\igobs$ $e$.raíz\DRef nombre $\yluego$ \\      
      (4g) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} def?(obtener($c$, $e$.categorías)\DRef padre\DRef nombre, $e$.categorías) $\yluego$ \\
      (4h) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías) $\in$ obtener($c$, $e$.categorías)\DRef padre\DRef hijos) $\land$ \\ 
      (4i) \hspace*{5mm} $¬$(obtener($c$, $e$.categorías)\DRef padre $\igobs$ NULL) $\impluego$ \\
          \hspace*{20mm} obtener($c$, $e$.categorías)\DRef padre\DRef id < \ obtener($c$, $e$.categorías)\DRef id))
  }

  \mbox{}

  \Abs[estr\_acat]{acat}[e]{ac}
    {categorias($ac$) $\igobs$ claves($e$.categorías) $\yluego$ \\
    raíz($ac$) $\igobs$ $e$.raíz\DRef nombre $\land$ \\
    ($\forall c$: categoria)($c$ $\in$ claves($e$.categorías) $\impluego$ ( \\
    \hspace*{5mm} padre($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef padre\DRef nombre $\land$ \\
    \hspace*{5mm} id($ac$, $c$) $\igobs$ obtener($c$, $e$.categorías)\DRef id))
  }

  ~

  \Titulo{Representación del iterador de hijos directos}  
  
  \begin{Estructura}{itercathijos}[itConj(estr\_cat)]
  \end{Estructura}
  
  PENDIENTE: Rep y Abs.

  ~  
  
  \Titulo{Representación del iterador de ancestros}  
  
  \begin{Estructura}{itercatancestros}[puntero(estr\_cat)]
  \end{Estructura} 

  PENDIENTE: Rep y Abs.

  ~    

\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearÁrbol}{\In{raiz}{categoria}}{estr\_acat}
  	\STATE var $raiz\_estr$: \TipoVariable{estr\_cat}
	\STATE var $categorias$: \TipoVariable{dicctrie(estr\_cat)}
  	\STATE
    \STATE $raiz\_estr$ $\leftarrow$ $\langle$\TipoVariable{id}: 1, \TipoVariable{nombre}: $raiz$,
                                      \TipoVariable{padre}: NULL, \TipoVariable{hijos}: \NombreFuncion{Vacío}()$\rangle$
    \STATE $categorias$ $\leftarrow$ \NombreFuncion{CrearDiccionario}()
  	\STATE    
    \STATE \NombreFuncion{Definir}($raiz$, $raiz\_estr$, $categorias$)
   	\STATE
  	\STATE $res$ $\leftarrow$ $\langle$\TipoVariable{raiz}: $raiz\_estr$, \TipoVariable{categorias}: $categorias\rangle$
  \end{Algoritmo}

  ~  
   
  \begin{Algoritmo}{iNombreCategoríaRaíz}{\In{ac}{estr\_acat}}{categoria}
	\STATE $res$ $\leftarrow$ $ac$.raíz.nombre
  \end{Algoritmo}  

  ~
  
  \begin{Algoritmo}{iAgregarCategoría}{\In{hija}{categoria}, \In{padre}{categoria}, \Inout{ac}{estr\_acat}}{}
  	\STATE var $estr\_hija$: \TipoVariable{estr\_cat}
  	\STATE $estr\_hija$ $\leftarrow$ $\langle$\TipoVariable{id}: \NombreFuncion{\#Claves}($ac$.categorías) + 1,
  	                                          \TipoVariable{nombre}: $hija$, \\
  	                                          \hspace*{22mm}
  	                                          \TipoVariable{padre}: \NombreFuncion{Obtener}($padre$, $ac$.categorías),
  	                                          \TipoVariable{hijos}: \NombreFuncion{Vacío}() $\rangle$
    \STATE \NombreFuncion{Definir}($hija$, $estr\_hija$, $ac$)
  \end{Algoritmo}

  ~   
    
  \begin{Algoritmo}{iIdCategoríaPorNombre}{\In{c}{categoria}, \In{ac}{estr\_acat}}{nat}
  	\STATE $res$ $\leftarrow$ \NombreFuncion{Obtener}($c$, $ac$.categorías).id
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{i\#Categorías}{\In{ac}{estr\_acat}}{nat}
  	\STATE $res$ $\leftarrow$ \NombreFuncion{\#Claves}($ac$.categorías)
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearIterHijos}{\In{padre}{categoria}, \In{ac}{acat}}{itConj(estr\_cat)}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Obtener}($padre$, $ac$.categorías).hijos)
  \end{Algoritmo}

  ~

  \begin{Algoritmo}{iCrearIterHijosDeLaRaíz}{\In{ac}{acat}}{itConj(estr\_cat)}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}($ac$.raíz.hijos)
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iCrearIterHijosDadoOtroIter}{\In{it}{itConj(estr\_cat)}}{itConj(estr\_cat)}
    \STATE $res$ $\leftarrow$ \NombreFuncion{CrearIt}(\NombreFuncion{Siguiente}(it).hijos)
  \end{Algoritmo}  

  ~  
  
  \begin{Algoritmo}{iHayMásHijos?}{\In{it}{itConj(estr\_cat)}}{bool}
    \STATE $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$)
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iHijoActual}{\In{it}{itConj(estr\_cat)}}{categoria}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$).nombre
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iIdHijoActual}{\In{it}{itConj(estr\_cat)}}{nat}
    \STATE $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$).id
  \end{Algoritmo}  
  
  ~
  
  \begin{Algoritmo}{iAvanzarHijo}{\Inout{it}{itConj(estr\_cat)}}{}
    \STATE \NombreFuncion{Avanzar}($it$)
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCrearIterAncestros}{\In{it}{itConj(estr\_cat)}}{puntero(estr\_cat)}
    \STATE $res$ $\leftarrow$ \&(\NombreFuncion{Siguiente}(it).padre)
  \end{Algoritmo}
 
  ~ 
  
  \begin{Algoritmo}{iCrearIterAncestrosDeLaRaíz}{\In{ac}{acat}}{puntero(estr\_cat)}
    \STATE $res$ $\leftarrow$ \&($ac$.raíz)
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iCopiarIterAncestros}{\In{it}{puntero(estr\_cat)}}{puntero(estr\_cat)}
    \STATE $res$ $\leftarrow$ \&(*$it$)
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iHayMásAncestros?}{\In{it}{puntero(estr\_cat)}}{bool}
    \STATE $res$ $\leftarrow$ $it$ $\igobs$ NULL
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iAncestroActual}{\In{it}{puntero(estr\_cat)}}{categoria}
    \STATE $res$ $\leftarrow$ $it$\DRef nombre
  \end{Algoritmo}

  ~
  
  \begin{Algoritmo}{iIdAncestroActual}{\In{it}{puntero(estr\_cat)}}{nat}
    \STATE $res$ $\leftarrow$ $it$\DRef id
  \end{Algoritmo}
  
  ~
  
  \begin{Algoritmo}{iAvanzarAncestro}{\Inout{it}{puntero(estr\_cat)}}{}
    \STATE $it$ $\leftarrow$ $it$\DRef padre
  \end{Algoritmo}

\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LinkLinkIt                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Módulo LinkLinkIt}

\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{LinkLinkIt}, \tadNombre{Iterador Unidireccional(Link)}.

  \textbf{géneros}: \TipoVariable{sistema}, \TipoVariable{iterlinks}.

  \Titulo{Operaciones básicas del sistema}
  
  \InterfazFuncion{CrearSistema}{\In{ac}{acat}}{sistema}
  {$res$ $\igobs$ iniciar($ac$)}
  [$\Theta$(\#(categorías($ac$))]
  [crea un sistema cuyo árbol de categorías es $ac$.]

  \InterfazFuncion{AgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $¬$($l$ $\in$ links($s$)) $\land$ está?($c$, categorías($s$)]
  {$s$ $\igobs$ nuevoLink($s_{0}$, $l$, $c$)}
  [$\Theta$(|$l$| + |$c$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [agrega al sistema el link $l$ con categoría $c$.]

  \InterfazFuncion{AccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{sistema}}{}
  [$s$ $\igobs$ $s_{0}$ $\land$ $l$ $\in$ links($s$) $\land$ $f$ $\geq$ fechaActual($s$)]
  {$s$ $\igobs$ acceso($s_{0}$, $l$, $f$)}
  [$\Theta$(|$l$| + $h$), donde $h$ representa altura(categorías($s$)).]
  [registra un acceso al link $l$ en la fecha $f$.]

  \InterfazFuncion{\#Links}{\In{c}{categoría}, \In{s}{sistema}}{nat}
  [está?($c$, categorías($s$))]
  {$res$ $\igobs$ cantLinks($s$, $c$)}
  [$\Theta$(|$c$|)]
  [devuelve la cantidad de links bajo la categoría $c$ y todas sus subcategorías.]

  \InterfazFuncion{CrearIterLinks}{\In{c}{categoría}, \In{s}{sistema}}{iterlinks}
  [está?($c$, categorías($s$))]
  {alias(SecuSuby($res$) $\igobs$ linksOrdenadosPorAccesos($ac$, $padre$)) $\land$ vacia?(Anteriores($res$))}
  [$\Theta$(|$c$| + $n$·log($n$)), donde $n$ representa long(linksOrdenadosPorAccesos($s$, $c$)).]
  [devuelve un iterador unidireccional de los links de la categoría $c$ y todas sus subcategorías ordenados de mayor a menor cantidad de accesos recientes.]
  
  \Titulo{Operaciones de iterador de links}
  
  \InterfazFuncion{HayMás?}{\In{it}{iterlinks}}{bool}
  {$res$ $\igobs$ HayMás?($it$)}
  [$\Theta(1)$]
  [devuelve \textbf{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{LinkActual}{\In{it}{iterlinks}}{link}
  [HayMás?($it$)]
  {$res$ $\igobs$ Actual($it$)}
  [$\Theta(1)$]
  [devuelve el link actual del iterador.]

  \InterfazFuncion{CategoríaLinkActual}{\In{it}{iterlinks}}{categoria}
  [HayMás?($it$)]
  {$res$ $\igobs$ categoríaLink(???, Actual($it$))}
  [$\Theta(1)$]
  [devuelve la categoría del link actual del iterador.]
  
  DUDA: En la postcondición no dispongo de un sistema para la llamada a categoríaLink, pues la
        interfaz de la función no recibe un sistema como parámetro ya que toda la información
        que necesita el algoritmo está contenida en el iterador. ¿Cómo hago para especificar
        la postcondición si no tengo un sistema?
        

  \InterfazFuncion{AccesosRecientesLinkActual}{\In{it}{iterlinks}}{nat}
  [HayMás?($it$)]
  {$res$ $\igobs$ accesosRecientes(???, ???, Actual($it$))}
  [$\Theta(1)$]
  [devuelve la cantidad de accesos del link actual del iterador durante los días de la intersección
   de los tres días ``recientes'' del link $l$ y de los tres días ``recientes'' del link que tuvo
   último acceso entre los links de la categoría $c$ con la que se creó este iterador, y los links
   de todas sus subcategorías.]

  DUDA: Misma duda que en la función anterior: ¿cómo hago para especificar la postcondición si
        no dispongo ni de la categoría ni del sistema para la llamada a accesosRecientes?

  \InterfazFuncion{Avanzar}{\Inout{it}{iterlinks}}{}
  [$it$ $\igobs$ $it_{0}$ $\land$ HayMás?($it$)]
  {$res$ $\igobs$ Avanzar($it_{0}$)}
  [$\Theta(1)$]
  [avanza el iterador a la posición siguiente.]  
  
\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación del sistema}
  
  \begin{Estructura}{sistema}[estr\_sistema]
    \begin{Tupla}[estr\_sistema]
      \tupItem{categorías}{acat}
      \tupItem{links}{dicctrie(estr\_link)}
      \tupItem{linksPorCatId}{arreglo\_dimensionable de estr\_linkscat}
      \tupItem{fechaActual}{fecha}
    \end{Tupla}
    \begin{Tupla}[estr\_link]
      \tupItem{l}{link}
      \tupItem{cid}{nat}
      \tupItem{últimoAcceso}{fecha}
      \tupItem{as}{arreglo\_estático[3] de fecha}            
    \end{Tupla} \\
    \begin{Tupla}[estr\_linkscat]
      \tupItem{itcat}{itcatancestros}
      \tupItem{ls}{lista(estr\_link)}
      \tupItem{últimoAcceso}{fecha}      
      \tupItem{ordenado?}{bool}            
    \end{Tupla}    
  \end{Estructura}
  
  \Titulo{Representación de iterador de links}  
  
  \begin{Estructura}{iterlinks}[estr\_iter]
    \begin{Tupla}[estr\_iter]
      \tupItem{s}{estr\_sistema}
      \tupItem{c}{categoria}
      \tupItem{it}{itLista(estr\_link)}
    \end{Tupla}
  \end{Estructura}
  
\end{Representacion}

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearSistema}{\In{ac}{estr\_acat}}{estr\_sistema}
    \STATE $res$ $\leftarrow$ $\langle$\TipoVariable{categorías}: $ac$, \TipoVariable{links}: \NombreFuncion{CrearDiccionario}(),\\
                        \hspace*{11mm} \TipoVariable{linksPorCatId}: \NombreFuncion{CrearArreglo}(\NombreFuncion{\#Categorías}($ac$)),
                                       \TipoVariable{fechaActual}: 0$\rangle$
    \STATE
    \STATE $s$.linksPorCatId[1] $\leftarrow$
            $\langle$\TipoVariable{itcat}: \NombreFuncion{CrearIterAncestrosDeLaRaíz}($as$), \TipoVariable{ls}: \NombreFuncion{Vacía}(), \\
      \hspace*{34mm} \TipoVariable{últimoAcceso}: 0, \TipoVariable{ordenado?}: \textbf{false}$\rangle$
    \STATE \NombreFuncion{iAgregarALinksPorCatId(CrearIterHijosDeLaRaíz($ac$), $s$)}   
  \end{Algoritmo}
  
  ~
  
  DUDA: ¿Está bien crear un auxiliar como a continuación?
  
  ~  
  
  \begin{Algoritmo}{iAgregarALinksPorCatId}{\Inout{it}{itercathijos}, \Inout{s}{estr\_sistema}}{}
    \WHILE{\NombreFuncion{HayMásHijos?}($it$)}
      \STATE $s$.linksPorCatId[\NombreFuncion{IdHijoActual}(it)] $\leftarrow$
              $\langle$\TipoVariable{itcat}: \NombreFuncion{CrearIterAncestros}($it$), \TipoVariable{ls}: \NombreFuncion{Vacía}(), \\
        \hspace*{62mm} \TipoVariable{últimoAcceso}: 0, \TipoVariable{ordenado?}: \textbf{false}$\rangle$
      \STATE \NombreFuncion{iAgregarALinksPorCatId}(\NombreFuncion{CrearIterHijosDadoOtroIter}($it$), $s$)
    \ENDWHILE
  \end{Algoritmo}
    
  ~  
  
  \begin{Algoritmo}{iAgregarLink}{\In{l}{link}, \In{c}{categoria}, \Inout{s}{estr\_sistema}}{}
  	\STATE var $estr\_l$: \TipoVariable{estr\_link}
  	\STATE $estr\_l$ $\leftarrow$ $\langle$\TipoVariable{l}: $l$,
  	                                       \TipoVariable{cid}: \NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías),\\
                            \hspace*{16mm} \TipoVariable{últimoAcceso}: $s$.fechaActual,
  	                                       \TipoVariable{as}: \NombreFuncion{CrearArreglo}()$\rangle$
 	\STATE $estr\_l$.as[0] $\leftarrow$ 0
 	\STATE $estr\_l$.as[1] $\leftarrow$ 0
 	\STATE $estr\_l$.as[2] $\leftarrow$ 0
 	\STATE \NombreFuncion{Definir}($l$, $estr\_l$, $s$.links)
 	\STATE
 	\STATE var $actual$: \TipoVariable{estr\_linkscat}
 	\STATE $actual$ $\leftarrow$ $s$.linksPorCatId[$estr\_l$.cid]
 	\STATE 	
 	\STATE var $hayMasCategorias$: \TipoVariable{bool} 	
 	\STATE $hayMasCategorias$ $\leftarrow$ \textbf{true}
 	\STATE
 	\WHILE{$hayMasCategorias$}
      \STATE \NombreFuncion{AgregarAtrás}($actual$.links, \&$estr\_l$)
 	  \STATE $actual$.últimoAcceso $\leftarrow$ $s$.fechaActual
 	  \STATE $actual$.ordenado? $\leftarrow$ \textbf{false}
 	  \IF{\NombreFuncion{ObtenerPadre}($actual$.c) $\igobs$ NULL)}
 	    \STATE $hayMasCategorias$ $\leftarrow$ \textbf{false}
 	  \ELSE
 	    \STATE $actual$ $\leftarrow$ $s$.linksPorCatId[\NombreFuncion{ObtenerId}(*\NombreFuncion{ObtenerPadre}($actual$.c))]
 	  \ENDIF
 	\ENDWHILE
  	
  	\STATE
  	\STATE DUDA: Al crear la tupla estr\_l y guardar en ésta el nombre del link (el cual es un vector de chars), ¿alcanza con
  	             hacer $tal\_cosa$ $\leftarrow$ $link$ o hay que hacer una copia del link?
  	
  	\STATE
  	\STATE DUDA: Dentro del while, cuando hago $actual$ $\leftarrow$ $s$.linksPorCatId[...], ¿se está almacenando
  	             una referencia dentro de $actual$ o se está almacenando una copia?
  	
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccederLink}{\In{l}{link}, \In{f}{fecha}, \Inout{s}{estr\_sistema}}{}
    \STATE var $estr\_l$: \TipoVariable{puntero(estr\_link)}
    \STATE $estr\_l$ $\leftarrow$ \NombreFuncion{Obtener}($l$, $s$.links)
	\IF{$f$ $\igobs$ $estr\_l$\DRef últimoAcceso}
	  \STATE $estr\_l$\DRef as[0] $\leftarrow$ $estr\_l$\DRef as[0] + 1
	\ELSIF{$f$ $\igobs$ $estr\_l$\DRef últimoAcceso + 1}
	  \STATE $estr\_l$\DRef as[2] $\leftarrow$ $estr\_l$\DRef as[1]
	  \STATE $estr\_l$\DRef as[1] $\leftarrow$ $estr\_l$\DRef as[0]
	  \STATE $estr\_l$\DRef as[0] $\leftarrow$ 1
	\ELSIF{$f$ $\igobs$ $estr\_l$\DRef últimoAcceso + 2}
	  \STATE $estr\_l$\DRef as[2] $\leftarrow$ $estr\_l$\DRef as[0]
	  \STATE $estr\_l$\DRef as[1] $\leftarrow$ 0
	  \STATE $estr\_l$\DRef as[0] $\leftarrow$ 1
	\ELSE
	  \STATE $estr\_l$\DRef as[2] $\leftarrow$ 0
	  \STATE $estr\_l$\DRef as[1] $\leftarrow$ 0
	  \STATE $estr\_l$\DRef as[0] $\leftarrow$ 1
	\ENDIF
 	\STATE
 	\STATE $s$.fechaActual $\leftarrow$ $f$	
 	\STATE
 	\STATE var $actual$: \TipoVariable{estr\_linkscat}
 	\STATE $actual$ $\leftarrow$ $s$.linksPorCatId[$estr\_l$.cid]
 	\STATE
 	\STATE var $hayMasCategorias$: \TipoVariable{bool} 	
 	\STATE $hayMasCategorias$ $\leftarrow$ \textbf{true}
  	\STATE
 	\WHILE{$hayMasCategorias$}
 	  \STATE $actual$.últimoAcceso $\leftarrow$ $s$.fechaActual
 	  \STATE $actual$.ordenado? $\leftarrow$ \textbf{false}
 	  \IF{\NombreFuncion{ObtenerPadre}($actual$.c) $\igobs$ NULL)}
 	    \STATE $hayMasCategorias$ $\leftarrow$ \textbf{false}
 	  \ELSE
 	    \STATE $actual$ $\leftarrow$ $s$.linksPorCatId[\NombreFuncion{ObtenerId}(*\NombreFuncion{ObtenerPadre}($actual$.c))]
 	  \ENDIF
 	\ENDWHILE  
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{i\#Links}{\In{c}{categoría}, \In{s}{estr\_sistema}}{nat}
	\STATE
	\STATE PENDIENTE: Agregar un nuevo campo a estr\_linkscat que contenga la cantidad de links de la categoría y sus subcategorías.
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iCrearIterLinks}{\In{c}{categoría}, \In{s}{estr\_sistema}}{estr\_iter}
    \STATE var $estr\_c$: \TipoVariable{estr\_linkscat}
  	\STATE $estr\_c$ $\leftarrow$ $s$.linksPorCatId[\NombreFuncion{IdCategoríaPorNombre}($c$, $s$.categorías)]
  	\STATE
  	\IF{$¬$($estr\_c$.ordenado?)}
  	  \STATE
  	  \STATE PENDIENTE: Ordenar links en $estr\_c$.ls
  	  \STATE
  	  \STATE $estr\_c$.ordenado? $\leftarrow$ \textbf{true}
  	\ENDIF
  	\STATE
    \STATE $res$ $\leftarrow$ $\langle$\TipoVariable{s}: $s$, \TipoVariable{c}: $c$, $it$: \NombreFuncion{CrearIt}($estr\_c$.ls)$\rangle$
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iHayMás?}{\In{it}{estr\_iter}}{bool}
    $res$ $\leftarrow$ \NombreFuncion{HaySiguiente}($it$.it)
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iLinkActual}{\In{it}{estr\_iter}}{link}
    $res$ $\leftarrow$ \NombreFuncion{Siguiente}($it$.it)\DRef l
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iCategoríaLinkActual}{\In{it}{estr\_iter}}{categoria}
    $res$ $\leftarrow$ \NombreFuncion{ObtenerNombre}(*($s$.linksPorCatId[\NombreFuncion{Siguiente}($it$.it)\DRef cid].c))
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAccesosRecientesLinkActual}{\In{it}{estr\_iter}}{nat}
    \STATE
    \STATE PENDIENTE
  \end{Algoritmo}
  
  ~  
  
  \begin{Algoritmo}{iAvanzar}{\Inout{it}{estr\_iter}}{}
    \NombreFuncion{Avanzar}($it$.it)
  \end{Algoritmo}
  
\end{Algoritmos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diccionario Trie                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Módulo Diccionario Trie($\alpha$)}

\begin{Interfaz}
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Diccionario(String, $\alpha$)}, \tadNombre{Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{dicctrie$(\alpha)$}, \TipoVariable{iterdicctrie($\alpha$)}.

  \Titulo{Operaciones básicas de diccionario trie}
  
  \InterfazFuncion{CrearDiccionario}{}{dicctrie$(\alpha)$}
  {$res$ $\igobs$ vacío()}
  [$\Theta(1)$]
  [crea un nuevo diccionario vacío.]

  \InterfazFuncion{Definido?}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{bool}
  {$res$ $\igobs$ def?($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve \textbf{true} si y sólo si $c$ está definido en el diccionario.]

  \InterfazFuncion{Definir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{d}{dicctrie$(\alpha)$}}{}
  [$d$ $\igobs$ $d_{0}$]
  {$d$ $\igobs$ definir($d_{0}$, $c$, $s$)}
  [$\Theta(|c| + copy(s))$]
  [define la clave $c$ con el significado $s$ en el diccionario.]
  
  \InterfazFuncion{Obtener}{\In{c}{string}, \In{d}{dicctrie$(\alpha)$}}{$\alpha$}
  [def?($c$, $d$)]
  {$res$ $\igobs$ obtener($c$, $d$)}
  [$\Theta(|c|)$]
  [devuelve el significado de la clave $c$ en $d$.]  
   
  \InterfazFuncion{\#Claves}{\In{d}{dicctrie$(\alpha)$}}{nat}
  {$res$ $\igobs$ \#(claves($d$))}
  [$\Theta(1)$]
  [devuelve la cantidad de claves del diccionario.]    

\end{Interfaz}

~

\begin{Representacion}
  \Titulo{Representación de diccionario trie}
  
  \begin{Estructura}{dicctrie$(\alpha)$}[estr\_dicctrie]
   \begin{Tupla}[estr\_dicctrie]
   \tupItem{cantClaves}{nat}
   \tupItem{nodos}{nodo}
   \end{Tupla}
     \begin{Tupla}[nodo]
      \tupItem{nodos}{arreglo\_estático[256] de puntero(nodo)}
      \tupItem{significado}{puntero$(\alpha)$}
    \end{Tupla}
  \end{Estructura}
  
    \Abs[estr\_dicctrie]{dicc(string, $\alpha$)}[e]{d}
    {($\forall c$: string) Definido?($c$, $e$) $\igobs$ def?($c$, $d$) $\land$ \\
    Definido?($c$,$e$) $\impluego$ (Obtener($c$, $e$) $\igobs$ obtener($c$, $e$))}
  
\end{Representacion}

~

\begin{Algoritmos}

  \begin{Algoritmo}{iCrearDiccionario}{}{estr\_dicctrie}
   \STATE var $i$: \TipoVariable{nat}
   \STATE $res$.cantClaves $\leftarrow$ 0
   \STATE for $i$=0 to |$res$.nodos| do:
   \STATE \hspace*{10mm} $res$.nodos[i] $\leftarrow$ false
\STATE endFor
\STATE $res$.nodos.significado $\leftarrow$ NULL
  \end{Algoritmo}

  ~
   
  \begin{Algoritmo}{iObtener}{\In{c}{string}, \In{e}{estr\_dicctrie}}{$\alpha$}
   \STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$ \NombreFuncion{\&}($e.nodos$)
   \STATE var $i$: \TipoVariable{nat}
   \STATE for $i$=0 to |$c$| do:
   \STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
\STATE endFor
    \STATE $res$ $\leftarrow$ (*$nodoActual$).(*$significado$)
  \end{Algoritmo}

  ~
   
  \begin{Algoritmo}{iDefinir}{\In{c}{string}, \In{s}{$\alpha$}, \Inout{e}{estr\_dicctrie}}{}
   \STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$ \NombreFuncion{\&}($e.nodos$)
   \STATE var $i$: \TipoVariable{nat}
   \STATE for $i$=0 to |$c$| do:
   \STATE \hspace*{10mm} if (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] = NULL then:
   \STATE \hspace*{20mm} var $nuevoNodo$: \TipoVariable{nodo}
\STATE \hspace*{20mm} for $j$=0 to |$nuevoNodo.nodos$| do:
\STATE \hspace*{30mm} $nuevoNodo$.nodos[$i$] $\leftarrow$ NULL
\STATE \hspace*{20mm} endFor
\STATE \hspace*{20mm} $nuevoNodo$.significiado $\leftarrow$ NULL

\STATE \hspace*{20mm}(*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] $\leftarrow$ \NombreFuncion{\&}($nuevoNodo$)
\STATE \hspace*{10mm} endIf
\STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
\STATE endFor
\STATE (*$nodoActual$).significado $\leftarrow$ \NombreFuncion{\&}(\NombreFuncion{Copia}($s$))
\STATE $e$.cantClaves++
  \end{Algoritmo}

  ~
   
    \begin{Algoritmo}{iDefinido?}{\In{c}{string}, \In{e}{estr\_dicctrie}}{bool}
    \STATE var $i$: \TipoVariable{nat}
   \STATE var $nodoActual$: \TipoVariable{puntero(nodo)} $\leftarrow$ \NombreFuncion{\&}($e.nodos$)
   \STATE while $i$ < |$c$| $\land$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])] != NULL do:
   \STATE \hspace*{10mm} $nodoActual$ $\leftarrow$ (*$nodoActual$).nodos[\NombreFuncion{ord}($c$[$i$])]
   \STATE \hspace*{10mm} $i$++
\STATE endWhile
\STATE $res$ $\leftarrow$ ($i$ = |$c$|-1 $\land$ (*$nodoActual$).siginficado != NULL)
  \end{Algoritmo}

  ~
     
 \begin{Algoritmo}{i\#Claves}{}{nat}
  $res$ $\leftarrow$ $e$.cantClaves
 \end{Algoritmo}

\end{Algoritmos}

\end{document}